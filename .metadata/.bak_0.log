!SESSION 2021-12-27 20:17:42.816 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product -data C:\Users\asem\eclipse-workspace -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-27 20:17:45.022
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-27 20:17:46.021
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.021
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 20:17:46.022
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-27 20:17:47.487
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-27 20:17:47.487
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ea3491d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6012bee8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-27 20:17:55.776
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-27 21:12:34.536 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product -data file:/C:/Users/asem/eclipse-workspace/ -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-27 21:12:36.898
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.058
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.059
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.060
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.060
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.060
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.060
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.060
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-27 21:12:38.060
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-27 21:12:39.736
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-27 21:12:39.736
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e60890c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c680819,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-27 21:12:47.281
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:55:15.414
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:02.723
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:20.470
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:26.209
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:28.952
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:36.685
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:42.914
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:57.158
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-27 23:56:59.410
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-28 01:47:29.805
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 01:48:12.386
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.ResourceBundle;
import common.Delivery;
import common.GroupDelivery;
import common.Messages;
import common.MessagesClass;
import client.ChatClient;
import client.ClientUI;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class DeliveryInfoController implements Initializable {
	@FXML
	private DatePicker datetxt;

	@FXML
	private TextField nametxt;

	@FXML
	private TextField adresstxt;

	@FXML
	private TextField phonenumbertxt;

	@FXML
	private ComboBox<String> deliverytxt;

	@FXML
	private TextArea opentxt;

	@FXML
	private ComboBox<String> hourtxt;

	@FXML
	private ComboBox<String> minutetxt;

	@FXML
	private Text errtxt;

	@FXML
	private Spinner<Integer> partnersSpinner;

	@FXML
	private Text partnerstxt;

	@FXML
	private Text sharedtxt;

	public static boolean Delivery;

	public static String deliveryType;

	public static Delivery del;

	public static int randGroup;

	public static GroupDelivery gp;

	@FXML
	//go back to choose delivery type option
	void BackBtn(ActionEvent event) {
		Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
		stage.close();
		Stage primaryStage = new Stage();
		TypeOfOrderController TOOC = new TypeOfOrderController();
		try {
			TOOC.start(primaryStage);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	@FXML
	//go to payment page
	void goToPayment(ActionEvent event) throws Exception {
		//if any field left empty pops a message to user
		if (nametxt.getText().equals("") || adresstxt.getText().equals("") || phonenumbertxt.getText().equals("")
				|| datetxt.getValue() == (null) || deliverytxt.getSelectionModel().isEmpty()
				|| hourtxt.getSelectionModel().isEmpty() || minutetxt.getSelectionModel().isEmpty()) {
			errtxt.setText("  Enter details");
			return;
		}
		
		//take current date and hour
		SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(); // given date
		Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
		calendar.setTime(date); // assigns calendar to given date
		int hours = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
		int minutes = calendar.get(Calendar.MINUTE);

		//take picked date and hour from user
		String pickedDate = datetxt.getValue().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		Date CurrentDate = sdformat.parse(NormalUserHomePageController.sClock);
		Date picked_Date = sdformat.parse(pickedDate);
		int hour = Integer.parseInt(hourtxt.getValue());
		int minute = Integer.parseInt(minutetxt.getValue());
		
		//check if picked date and hour is legal
		if ((hours < hour && CurrentDate.compareTo(picked_Date) == 0)
				|| (minutes < minute && hours == hour && CurrentDate.compareTo(picked_Date) == 0)
				|| CurrentDate.compareTo(picked_Date) < 0) {
			Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
			stage.close();
			Stage primaryStage = new Stage();
			if (ChatClient.user.getUserType().equals("Normal") || (ChatClient.user.getUserType().equals("Bussiness")
					&& !deliverytxt.getValue().equals("Shared"))) {
				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			} 
			
			//check if business user picked shared delivery option
			//if yes -> generate random number between 10000-99999 of the group so that other users can join
			//save number of group and size to the data base
			else if ((ChatClient.user.getUserType().equals("Bussiness") && deliverytxt.getValue().equals("Shared"))
					&& partnersSpinner.getValue().intValue() > 0) {

				Random r = new Random();
				randGroup = r.nextInt(99999 - 10000) + 10000;
				ChatClient.numCode = randGroup;
				gp = new GroupDelivery(randGroup, partnersSpinner.getValue().intValue());
				MessagesClass msg = new MessagesClass(Messages.partnersGroupNumber, gp);

				ClientUI.chat.accept(msg);

				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}
		} else {
			errtxt.setText("Enter a valid date");
			return;
		}
	}

	public void start(Stage primaryStage) throws Exception {
		Delivery = false;
		Parent root = FXMLLoader.load(getClass().getResource("/gui/DeliveryInfoFXML.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("Delivery Info");
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		// phone number text field accept only number
		phonenumbertxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\d{0,10}?")) {
					phonenumbertxt.setText(oldValue);
				}
			}
		});

		//name text field accept only characters
		nametxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\sa-zA-Z*")) {
					nametxt.setText(newValue.replaceAll("[^\\sa-zA-Z]", ""));
				}
			}
		});

		//initialize hours from 0-23
		int i;
		for (i = 0; i < 24; i++) {
			if (i < 10)
				hourtxt.getItems().add("0" + String.valueOf(i));
			else
				hourtxt.getItems().add(String.valueOf(i));
		}
		//initialize minutes from 0-59
		for (i = 0; i < 60; i++) {
			if (i < 10)
				minutetxt.getItems().add("0" + i);
			else
				minutetxt.getItems().add(String.valueOf(i));
		}
		
		//initialize delivery types
		deliverytxt.getItems().add("Basic 25$");
		if (ChatClient.user.getUserType().equals("Bussiness"))
			deliverytxt.getItems().add("Shared");
		deliverytxt.getItems().add("Robot");

		//if user is not business type set invisible
		if
		partnerstxt.setVisible(false);
		partnersSpinner.setVisible(false);

		
		deliverytxt.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
			if (newValue.equals("Shared")) {
				deliveryType = "Shared";
				partnerstxt.setVisible(true);
				partnersSpinner.setVisible(true);
				sharedtxt.setVisible(true);
				SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 20,
						0);
				partnersSpinner.setValueFactory(valueFactory);

			} else {
				deliveryType = newValue;
				partnerstxt.setVisible(false);
				sharedtxt.setVisible(false);
				partnersSpinner.setVisible(false);
			}
		});

		//set shared group delivery prices according to number of people picked
		partnersSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {

			switch (partnersSpinner.getValue().intValue()) {
			case 0:
				sharedtxt.setText("25");
				break;
			case 1:
				sharedtxt.setText("20$");
				break;
			case 2:
				sharedtxt.setText("15$");
				break;
			case 3:
				sharedtxt.setText("15$");
				break;
			default:
				sharedtxt.setText("15$");
				break;
			}
		});

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 01:48:12.387
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:12.388
!MESSAGE offset 8299, count -895, length 8431
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:12.388
!MESSAGE offset 8299, count -895, length 8431
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 01:48:12.389
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:12.389
!MESSAGE offset 8299, count -895, length 8431
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8299, count -895, length 8431
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 01:48:14.894
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.ResourceBundle;
import common.Delivery;
import common.GroupDelivery;
import common.Messages;
import common.MessagesClass;
import client.ChatClient;
import client.ClientUI;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class DeliveryInfoController implements Initializable {
	@FXML
	private DatePicker datetxt;

	@FXML
	private TextField nametxt;

	@FXML
	private TextField adresstxt;

	@FXML
	private TextField phonenumbertxt;

	@FXML
	private ComboBox<String> deliverytxt;

	@FXML
	private TextArea opentxt;

	@FXML
	private ComboBox<String> hourtxt;

	@FXML
	private ComboBox<String> minutetxt;

	@FXML
	private Text errtxt;

	@FXML
	private Spinner<Integer> partnersSpinner;

	@FXML
	private Text partnerstxt;

	@FXML
	private Text sharedtxt;

	public static boolean Delivery;

	public static String deliveryType;

	public static Delivery del;

	public static int randGroup;

	public static GroupDelivery gp;

	@FXML
	//go back to choose delivery type option
	void BackBtn(ActionEvent event) {
		Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
		stage.close();
		Stage primaryStage = new Stage();
		TypeOfOrderController TOOC = new TypeOfOrderController();
		try {
			TOOC.start(primaryStage);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	@FXML
	//go to payment page
	void goToPayment(ActionEvent event) throws Exception {
		//if any field left empty pops a message to user
		if (nametxt.getText().equals("") || adresstxt.getText().equals("") || phonenumbertxt.getText().equals("")
				|| datetxt.getValue() == (null) || deliverytxt.getSelectionModel().isEmpty()
				|| hourtxt.getSelectionModel().isEmpty() || minutetxt.getSelectionModel().isEmpty()) {
			errtxt.setText("  Enter details");
			return;
		}
		
		//take current date and hour
		SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(); // given date
		Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
		calendar.setTime(date); // assigns calendar to given date
		int hours = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
		int minutes = calendar.get(Calendar.MINUTE);

		//take picked date and hour from user
		String pickedDate = datetxt.getValue().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		Date CurrentDate = sdformat.parse(NormalUserHomePageController.sClock);
		Date picked_Date = sdformat.parse(pickedDate);
		int hour = Integer.parseInt(hourtxt.getValue());
		int minute = Integer.parseInt(minutetxt.getValue());
		
		//check if picked date and hour is legal
		if ((hours < hour && CurrentDate.compareTo(picked_Date) == 0)
				|| (minutes < minute && hours == hour && CurrentDate.compareTo(picked_Date) == 0)
				|| CurrentDate.compareTo(picked_Date) < 0) {
			Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
			stage.close();
			Stage primaryStage = new Stage();
			if (ChatClient.user.getUserType().equals("Normal") || (ChatClient.user.getUserType().equals("Bussiness")
					&& !deliverytxt.getValue().equals("Shared"))) {
				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			} 
			
			//check if business user picked shared delivery option
			//if yes -> generate random number between 10000-99999 of the group so that other users can join
			//save number of group and size to the data base
			else if ((ChatClient.user.getUserType().equals("Bussiness") && deliverytxt.getValue().equals("Shared"))
					&& partnersSpinner.getValue().intValue() > 0) {

				Random r = new Random();
				randGroup = r.nextInt(99999 - 10000) + 10000;
				ChatClient.numCode = randGroup;
				gp = new GroupDelivery(randGroup, partnersSpinner.getValue().intValue());
				MessagesClass msg = new MessagesClass(Messages.partnersGroupNumber, gp);

				ClientUI.chat.accept(msg);

				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}
		} else {
			errtxt.setText("Enter a valid date");
			return;
		}
	}

	public void start(Stage primaryStage) throws Exception {
		Delivery = false;
		Parent root = FXMLLoader.load(getClass().getResource("/gui/DeliveryInfoFXML.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("Delivery Info");
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		// phone number text field accept only number
		phonenumbertxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\d{0,10}?")) {
					phonenumbertxt.setText(oldValue);
				}
			}
		});

		//name text field accept only characters
		nametxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\sa-zA-Z*")) {
					nametxt.setText(newValue.replaceAll("[^\\sa-zA-Z]", ""));
				}
			}
		});

		//initialize hours from 0-23
		int i;
		for (i = 0; i < 24; i++) {
			if (i < 10)
				hourtxt.getItems().add("0" + String.valueOf(i));
			else
				hourtxt.getItems().add(String.valueOf(i));
		}
		//initialize minutes from 0-59
		for (i = 0; i < 60; i++) {
			if (i < 10)
				minutetxt.getItems().add("0" + i);
			else
				minutetxt.getItems().add(String.valueOf(i));
		}
		
		//initialize delivery types
		deliverytxt.getItems().add("Basic 25$");
		if (ChatClient.user.getUserType().equals("Bussiness"))
			deliverytxt.getItems().add("Shared");
		deliverytxt.getItems().add("Robot");

		//if user is not business type set invisible
		if)
		partnerstxt.setVisible(false);
		partnersSpinner.setVisible(false);

		
		deliverytxt.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
			if (newValue.equals("Shared")) {
				deliveryType = "Shared";
				partnerstxt.setVisible(true);
				partnersSpinner.setVisible(true);
				sharedtxt.setVisible(true);
				SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 20,
						0);
				partnersSpinner.setValueFactory(valueFactory);

			} else {
				deliveryType = newValue;
				partnerstxt.setVisible(false);
				sharedtxt.setVisible(false);
				partnersSpinner.setVisible(false);
			}
		});

		//set shared group delivery prices according to number of people picked
		partnersSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {

			switch (partnersSpinner.getValue().intValue()) {
			case 0:
				sharedtxt.setText("25");
				break;
			case 1:
				sharedtxt.setText("20$");
				break;
			case 2:
				sharedtxt.setText("15$");
				break;
			case 3:
				sharedtxt.setText("15$");
				break;
			default:
				sharedtxt.setText("15$");
				break;
			}
		});

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 01:48:14.895
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:14.895
!MESSAGE offset 8300, count -895, length 8432
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:14.895
!MESSAGE offset 8300, count -895, length 8432
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 01:48:14.895
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:14.895
!MESSAGE offset 8300, count -895, length 8432
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-28 01:48:14.999
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-28 01:48:14.999
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-28 01:48:16.232
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-28 01:48:16.232
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8300, count -895, length 8432
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 01:48:18.402
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.ResourceBundle;
import common.Delivery;
import common.GroupDelivery;
import common.Messages;
import common.MessagesClass;
import client.ChatClient;
import client.ClientUI;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class DeliveryInfoController implements Initializable {
	@FXML
	private DatePicker datetxt;

	@FXML
	private TextField nametxt;

	@FXML
	private TextField adresstxt;

	@FXML
	private TextField phonenumbertxt;

	@FXML
	private ComboBox<String> deliverytxt;

	@FXML
	private TextArea opentxt;

	@FXML
	private ComboBox<String> hourtxt;

	@FXML
	private ComboBox<String> minutetxt;

	@FXML
	private Text errtxt;

	@FXML
	private Spinner<Integer> partnersSpinner;

	@FXML
	private Text partnerstxt;

	@FXML
	private Text sharedtxt;

	public static boolean Delivery;

	public static String deliveryType;

	public static Delivery del;

	public static int randGroup;

	public static GroupDelivery gp;

	@FXML
	//go back to choose delivery type option
	void BackBtn(ActionEvent event) {
		Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
		stage.close();
		Stage primaryStage = new Stage();
		TypeOfOrderController TOOC = new TypeOfOrderController();
		try {
			TOOC.start(primaryStage);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	@FXML
	//go to payment page
	void goToPayment(ActionEvent event) throws Exception {
		//if any field left empty pops a message to user
		if (nametxt.getText().equals("") || adresstxt.getText().equals("") || phonenumbertxt.getText().equals("")
				|| datetxt.getValue() == (null) || deliverytxt.getSelectionModel().isEmpty()
				|| hourtxt.getSelectionModel().isEmpty() || minutetxt.getSelectionModel().isEmpty()) {
			errtxt.setText("  Enter details");
			return;
		}
		
		//take current date and hour
		SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(); // given date
		Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
		calendar.setTime(date); // assigns calendar to given date
		int hours = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
		int minutes = calendar.get(Calendar.MINUTE);

		//take picked date and hour from user
		String pickedDate = datetxt.getValue().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		Date CurrentDate = sdformat.parse(NormalUserHomePageController.sClock);
		Date picked_Date = sdformat.parse(pickedDate);
		int hour = Integer.parseInt(hourtxt.getValue());
		int minute = Integer.parseInt(minutetxt.getValue());
		
		//check if picked date and hour is legal
		if ((hours < hour && CurrentDate.compareTo(picked_Date) == 0)
				|| (minutes < minute && hours == hour && CurrentDate.compareTo(picked_Date) == 0)
				|| CurrentDate.compareTo(picked_Date) < 0) {
			Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
			stage.close();
			Stage primaryStage = new Stage();
			if (ChatClient.user.getUserType().equals("Normal") || (ChatClient.user.getUserType().equals("Bussiness")
					&& !deliverytxt.getValue().equals("Shared"))) {
				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			} 
			
			//check if business user picked shared delivery option
			//if yes -> generate random number between 10000-99999 of the group so that other users can join
			//save number of group and size to the data base
			else if ((ChatClient.user.getUserType().equals("Bussiness") && deliverytxt.getValue().equals("Shared"))
					&& partnersSpinner.getValue().intValue() > 0) {

				Random r = new Random();
				randGroup = r.nextInt(99999 - 10000) + 10000;
				ChatClient.numCode = randGroup;
				gp = new GroupDelivery(randGroup, partnersSpinner.getValue().intValue());
				MessagesClass msg = new MessagesClass(Messages.partnersGroupNumber, gp);

				ClientUI.chat.accept(msg);

				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}
		} else {
			errtxt.setText("Enter a valid date");
			return;
		}
	}

	public void start(Stage primaryStage) throws Exception {
		Delivery = false;
		Parent root = FXMLLoader.load(getClass().getResource("/gui/DeliveryInfoFXML.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("Delivery Info");
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		// phone number text field accept only number
		phonenumbertxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\d{0,10}?")) {
					phonenumbertxt.setText(oldValue);
				}
			}
		});

		//name text field accept only characters
		nametxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\sa-zA-Z*")) {
					nametxt.setText(newValue.replaceAll("[^\\sa-zA-Z]", ""));
				}
			}
		});

		//initialize hours from 0-23
		int i;
		for (i = 0; i < 24; i++) {
			if (i < 10)
				hourtxt.getItems().add("0" + String.valueOf(i));
			else
				hourtxt.getItems().add(String.valueOf(i));
		}
		//initialize minutes from 0-59
		for (i = 0; i < 60; i++) {
			if (i < 10)
				minutetxt.getItems().add("0" + i);
			else
				minutetxt.getItems().add(String.valueOf(i));
		}
		
		//initialize delivery types
		deliverytxt.getItems().add("Basic 25$");
		if (ChatClient.user.getUserType().equals("Bussiness"))
			deliverytxt.getItems().add("Shared");
		deliverytxt.getItems().add("Robot");

		//if user is not business type set invisible
		if())
		partnerstxt.setVisible(false);
		partnersSpinner.setVisible(false);

		
		deliverytxt.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
			if (newValue.equals("Shared")) {
				deliveryType = "Shared";
				partnerstxt.setVisible(true);
				partnersSpinner.setVisible(true);
				sharedtxt.setVisible(true);
				SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 20,
						0);
				partnersSpinner.setValueFactory(valueFactory);

			} else {
				deliveryType = newValue;
				partnerstxt.setVisible(false);
				sharedtxt.setVisible(false);
				partnersSpinner.setVisible(false);
			}
		});

		//set shared group delivery prices according to number of people picked
		partnersSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {

			switch (partnersSpinner.getValue().intValue()) {
			case 0:
				sharedtxt.setText("25");
				break;
			case 1:
				sharedtxt.setText("20$");
				break;
			case 2:
				sharedtxt.setText("15$");
				break;
			case 3:
				sharedtxt.setText("15$");
				break;
			default:
				sharedtxt.setText("15$");
				break;
			}
		});

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 01:48:18.402
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:18.403
!MESSAGE offset 8302, count -895, length 8434
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:18.403
!MESSAGE offset 8302, count -895, length 8434
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 01:48:18.403
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:18.403
!MESSAGE offset 8302, count -895, length 8434
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-28 01:48:18.406
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-28 01:48:18.406
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8302, count -895, length 8434
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 01:48:19.906
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.ResourceBundle;
import common.Delivery;
import common.GroupDelivery;
import common.Messages;
import common.MessagesClass;
import client.ChatClient;
import client.ClientUI;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class DeliveryInfoController implements Initializable {
	@FXML
	private DatePicker datetxt;

	@FXML
	private TextField nametxt;

	@FXML
	private TextField adresstxt;

	@FXML
	private TextField phonenumbertxt;

	@FXML
	private ComboBox<String> deliverytxt;

	@FXML
	private TextArea opentxt;

	@FXML
	private ComboBox<String> hourtxt;

	@FXML
	private ComboBox<String> minutetxt;

	@FXML
	private Text errtxt;

	@FXML
	private Spinner<Integer> partnersSpinner;

	@FXML
	private Text partnerstxt;

	@FXML
	private Text sharedtxt;

	public static boolean Delivery;

	public static String deliveryType;

	public static Delivery del;

	public static int randGroup;

	public static GroupDelivery gp;

	@FXML
	//go back to choose delivery type option
	void BackBtn(ActionEvent event) {
		Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
		stage.close();
		Stage primaryStage = new Stage();
		TypeOfOrderController TOOC = new TypeOfOrderController();
		try {
			TOOC.start(primaryStage);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	@FXML
	//go to payment page
	void goToPayment(ActionEvent event) throws Exception {
		//if any field left empty pops a message to user
		if (nametxt.getText().equals("") || adresstxt.getText().equals("") || phonenumbertxt.getText().equals("")
				|| datetxt.getValue() == (null) || deliverytxt.getSelectionModel().isEmpty()
				|| hourtxt.getSelectionModel().isEmpty() || minutetxt.getSelectionModel().isEmpty()) {
			errtxt.setText("  Enter details");
			return;
		}
		
		//take current date and hour
		SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(); // given date
		Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
		calendar.setTime(date); // assigns calendar to given date
		int hours = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
		int minutes = calendar.get(Calendar.MINUTE);

		//take picked date and hour from user
		String pickedDate = datetxt.getValue().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		Date CurrentDate = sdformat.parse(NormalUserHomePageController.sClock);
		Date picked_Date = sdformat.parse(pickedDate);
		int hour = Integer.parseInt(hourtxt.getValue());
		int minute = Integer.parseInt(minutetxt.getValue());
		
		//check if picked date and hour is legal
		if ((hours < hour && CurrentDate.compareTo(picked_Date) == 0)
				|| (minutes < minute && hours == hour && CurrentDate.compareTo(picked_Date) == 0)
				|| CurrentDate.compareTo(picked_Date) < 0) {
			Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
			stage.close();
			Stage primaryStage = new Stage();
			if (ChatClient.user.getUserType().equals("Normal") || (ChatClient.user.getUserType().equals("Bussiness")
					&& !deliverytxt.getValue().equals("Shared"))) {
				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			} 
			
			//check if business user picked shared delivery option
			//if yes -> generate random number between 10000-99999 of the group so that other users can join
			//save number of group and size to the data base
			else if ((ChatClient.user.getUserType().equals("Bussiness") && deliverytxt.getValue().equals("Shared"))
					&& partnersSpinner.getValue().intValue() > 0) {

				Random r = new Random();
				randGroup = r.nextInt(99999 - 10000) + 10000;
				ChatClient.numCode = randGroup;
				gp = new GroupDelivery(randGroup, partnersSpinner.getValue().intValue());
				MessagesClass msg = new MessagesClass(Messages.partnersGroupNumber, gp);

				ClientUI.chat.accept(msg);

				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}
		} else {
			errtxt.setText("Enter a valid date");
			return;
		}
	}

	public void start(Stage primaryStage) throws Exception {
		Delivery = false;
		Parent root = FXMLLoader.load(getClass().getResource("/gui/DeliveryInfoFXML.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("Delivery Info");
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		// phone number text field accept only number
		phonenumbertxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\d{0,10}?")) {
					phonenumbertxt.setText(oldValue);
				}
			}
		});

		//name text field accept only characters
		nametxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\sa-zA-Z*")) {
					nametxt.setText(newValue.replaceAll("[^\\sa-zA-Z]", ""));
				}
			}
		});

		//initialize hours from 0-23
		int i;
		for (i = 0; i < 24; i++) {
			if (i < 10)
				hourtxt.getItems().add("0" + String.valueOf(i));
			else
				hourtxt.getItems().add(String.valueOf(i));
		}
		//initialize minutes from 0-59
		for (i = 0; i < 60; i++) {
			if (i < 10)
				minutetxt.getItems().add("0" + i);
			else
				minutetxt.getItems().add(String.valueOf(i));
		}
		
		//initialize delivery types
		deliverytxt.getItems().add("Basic 25$");
		if (ChatClient.user.getUserType().equals("Bussiness"))
			deliverytxt.getItems().add("Shared");
		deliverytxt.getItems().add("Robot");

		//if user is not business type set invisible
		if()
		partnerstxt.setVisible(false);
		partnersSpinner.setVisible(false);

		
		deliverytxt.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
			if (newValue.equals("Shared")) {
				deliveryType = "Shared";
				partnerstxt.setVisible(true);
				partnersSpinner.setVisible(true);
				sharedtxt.setVisible(true);
				SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 20,
						0);
				partnersSpinner.setValueFactory(valueFactory);

			} else {
				deliveryType = newValue;
				partnerstxt.setVisible(false);
				sharedtxt.setVisible(false);
				partnersSpinner.setVisible(false);
			}
		});

		//set shared group delivery prices according to number of people picked
		partnersSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {

			switch (partnersSpinner.getValue().intValue()) {
			case 0:
				sharedtxt.setText("25");
				break;
			case 1:
				sharedtxt.setText("20$");
				break;
			case 2:
				sharedtxt.setText("15$");
				break;
			case 3:
				sharedtxt.setText("15$");
				break;
			default:
				sharedtxt.setText("15$");
				break;
			}
		});

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 01:48:19.907
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:19.907
!MESSAGE offset 8301, count -895, length 8433
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:19.907
!MESSAGE offset 8301, count -895, length 8433
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 01:48:19.907
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:19.908
!MESSAGE offset 8301, count -895, length 8433
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8301, count -895, length 8433
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 01:48:25.961
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.ResourceBundle;
import common.Delivery;
import common.GroupDelivery;
import common.Messages;
import common.MessagesClass;
import client.ChatClient;
import client.ClientUI;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class DeliveryInfoController implements Initializable {
	@FXML
	private DatePicker datetxt;

	@FXML
	private TextField nametxt;

	@FXML
	private TextField adresstxt;

	@FXML
	private TextField phonenumbertxt;

	@FXML
	private ComboBox<String> deliverytxt;

	@FXML
	private TextArea opentxt;

	@FXML
	private ComboBox<String> hourtxt;

	@FXML
	private ComboBox<String> minutetxt;

	@FXML
	private Text errtxt;

	@FXML
	private Spinner<Integer> partnersSpinner;

	@FXML
	private Text partnerstxt;

	@FXML
	private Text sharedtxt;

	public static boolean Delivery;

	public static String deliveryType;

	public static Delivery del;

	public static int randGroup;

	public static GroupDelivery gp;

	@FXML
	//go back to choose delivery type option
	void BackBtn(ActionEvent event) {
		Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
		stage.close();
		Stage primaryStage = new Stage();
		TypeOfOrderController TOOC = new TypeOfOrderController();
		try {
			TOOC.start(primaryStage);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	@FXML
	//go to payment page
	void goToPayment(ActionEvent event) throws Exception {
		//if any field left empty pops a message to user
		if (nametxt.getText().equals("") || adresstxt.getText().equals("") || phonenumbertxt.getText().equals("")
				|| datetxt.getValue() == (null) || deliverytxt.getSelectionModel().isEmpty()
				|| hourtxt.getSelectionModel().isEmpty() || minutetxt.getSelectionModel().isEmpty()) {
			errtxt.setText("  Enter details");
			return;
		}
		
		//take current date and hour
		SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(); // given date
		Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
		calendar.setTime(date); // assigns calendar to given date
		int hours = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
		int minutes = calendar.get(Calendar.MINUTE);

		//take picked date and hour from user
		String pickedDate = datetxt.getValue().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		Date CurrentDate = sdformat.parse(NormalUserHomePageController.sClock);
		Date picked_Date = sdformat.parse(pickedDate);
		int hour = Integer.parseInt(hourtxt.getValue());
		int minute = Integer.parseInt(minutetxt.getValue());
		
		//check if picked date and hour is legal
		if ((hours < hour && CurrentDate.compareTo(picked_Date) == 0)
				|| (minutes < minute && hours == hour && CurrentDate.compareTo(picked_Date) == 0)
				|| CurrentDate.compareTo(picked_Date) < 0) {
			Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
			stage.close();
			Stage primaryStage = new Stage();
			if (ChatClient.user.getUserType().equals("Normal") || (ChatClient.user.getUserType().equals("Bussiness")
					&& !deliverytxt.getValue().equals("Shared"))) {
				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			} 
			
			//check if business user picked shared delivery option
			//if yes -> generate random number between 10000-99999 of the group so that other users can join
			//save number of group and size to the data base
			else if ((ChatClient.user.getUserType().equals("Bussiness") && deliverytxt.getValue().equals("Shared"))
					&& partnersSpinner.getValue().intValue() > 0) {

				Random r = new Random();
				randGroup = r.nextInt(99999 - 10000) + 10000;
				ChatClient.numCode = randGroup;
				gp = new GroupDelivery(randGroup, partnersSpinner.getValue().intValue());
				MessagesClass msg = new MessagesClass(Messages.partnersGroupNumber, gp);

				ClientUI.chat.accept(msg);

				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}
		} else {
			errtxt.setText("Enter a valid date");
			return;
		}
	}

	public void start(Stage primaryStage) throws Exception {
		Delivery = false;
		Parent root = FXMLLoader.load(getClass().getResource("/gui/DeliveryInfoFXML.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("Delivery Info");
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		// phone number text field accept only number
		phonenumbertxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\d{0,10}?")) {
					phonenumbertxt.setText(oldValue);
				}
			}
		});

		//name text field accept only characters
		nametxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\sa-zA-Z*")) {
					nametxt.setText(newValue.replaceAll("[^\\sa-zA-Z]", ""));
				}
			}
		});

		//initialize hours from 0-23
		int i;
		for (i = 0; i < 24; i++) {
			if (i < 10)
				hourtxt.getItems().add("0" + String.valueOf(i));
			else
				hourtxt.getItems().add(String.valueOf(i));
		}
		//initialize minutes from 0-59
		for (i = 0; i < 60; i++) {
			if (i < 10)
				minutetxt.getItems().add("0" + i);
			else
				minutetxt.getItems().add(String.valueOf(i));
		}
		
		//initialize delivery types
		deliverytxt.getItems().add("Basic 25$");
		if (ChatClient.user.getUserType().equals("Bussiness"))
			deliverytxt.getItems().add("Shared");
		deliverytxt.getItems().add("Robot");

		//if user is not business type set invisible
		if(ChatClient.user.)
		partnerstxt.setVisible(false);
		partnersSpinner.setVisible(false);

		
		deliverytxt.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
			if (newValue.equals("Shared")) {
				deliveryType = "Shared";
				partnerstxt.setVisible(true);
				partnersSpinner.setVisible(true);
				sharedtxt.setVisible(true);
				SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 20,
						0);
				partnersSpinner.setValueFactory(valueFactory);

			} else {
				deliveryType = newValue;
				partnerstxt.setVisible(false);
				sharedtxt.setVisible(false);
				partnersSpinner.setVisible(false);
			}
		});

		//set shared group delivery prices according to number of people picked
		partnersSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {

			switch (partnersSpinner.getValue().intValue()) {
			case 0:
				sharedtxt.setText("25");
				break;
			case 1:
				sharedtxt.setText("20$");
				break;
			case 2:
				sharedtxt.setText("15$");
				break;
			case 3:
				sharedtxt.setText("15$");
				break;
			default:
				sharedtxt.setText("15$");
				break;
			}
		});

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 01:48:25.962
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:25.962
!MESSAGE offset 8317, count -895, length 8449
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:25.962
!MESSAGE offset 8317, count -895, length 8449
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 01:48:25.962
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:48:25.962
!MESSAGE offset 8317, count -895, length 8449
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-28 01:48:26.224
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-28 01:48:26.224
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8317, count -895, length 8449
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:312)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1195)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 01:51:31.758
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.ResourceBundle;
import common.Delivery;
import common.GroupDelivery;
import common.Messages;
import common.MessagesClass;
import client.ChatClient;
import client.ClientUI;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class DeliveryInfoController implements Initializable {
	@FXML
	private DatePicker datetxt;

	@FXML
	private TextField nametxt;

	@FXML
	private TextField adresstxt;

	@FXML
	private TextField phonenumbertxt;

	@FXML
	private ComboBox<String> deliverytxt;

	@FXML
	private TextArea opentxt;

	@FXML
	private ComboBox<String> hourtxt;

	@FXML
	private ComboBox<String> minutetxt;

	@FXML
	private Text errtxt;

	@FXML
	private Spinner<Integer> partnersSpinner;

	@FXML
	private Text partnerstxt;

	@FXML
	private Text sharedtxt;

	public static boolean Delivery;

	public static String deliveryType;

	public static Delivery del;

	public static int randGroup;

	public static GroupDelivery gp;

	@FXML
	// go back to choose delivery type option
	void BackBtn(ActionEvent event) {
		Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
		stage.close();
		Stage primaryStage = new Stage();
		TypeOfOrderController TOOC = new TypeOfOrderController();
		try {
			TOOC.start(primaryStage);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	@FXML
	// go to payment page
	void goToPayment(ActionEvent event) throws Exception {
		// if any field left empty pops a message to user
		if (nametxt.getText().equals("") || adresstxt.getText().equals("") || phonenumbertxt.getText().equals("")
				|| datetxt.getValue() == (null) || deliverytxt.getSelectionModel().isEmpty()
				|| hourtxt.getSelectionModel().isEmpty() || minutetxt.getSelectionModel().isEmpty()) {
			errtxt.setText("  Enter details");
			return;
		}

		// take current date and hour
		SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(); // given date
		Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
		calendar.setTime(date); // assigns calendar to given date
		int hours = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
		int minutes = calendar.get(Calendar.MINUTE);

		// take picked date and hour from user
		String pickedDate = datetxt.getValue().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		Date CurrentDate = sdformat.parse(NormalUserHomePageController.sClock);
		Date picked_Date = sdformat.parse(pickedDate);
		int hour = Integer.parseInt(hourtxt.getValue());
		int minute = Integer.parseInt(minutetxt.getValue());

		// check if picked date and hour is legal
		if ((hours < hour && CurrentDate.compareTo(picked_Date) == 0)
				|| (minutes < minute && hours == hour && CurrentDate.compareTo(picked_Date) == 0)
				|| CurrentDate.compareTo(picked_Date) < 0) {
			Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
			stage.close();
			Stage primaryStage = new Stage();
			if (ChatClient.user.getUserType().equals("Normal") || (ChatClient.user.getUserType().equals("Bussiness")
					&& !deliverytxt.getValue().equals("Shared"))) {
				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}

			// check if business user picked shared delivery option
			// if yes -> generate random number between 10000-99999 of the group so that
			// other users can join
			// save number of group and size to the data base
			else if ((ChatClient.user.getUserType().equals("Bussiness") && deliverytxt.getValue().equals("Shared"))
					&& partnersSpinner.getValue().intValue() > 0) {

				Random r = new Random();
				randGroup = r.nextInt(99999 - 10000) + 10000;
				ChatClient.numCode = randGroup;
				gp = new GroupDelivery(randGroup, partnersSpinner.getValue().intValue());
				MessagesClass msg = new MessagesClass(Messages.partnersGroupNumber, gp);

				ClientUI.chat.accept(msg);

				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}
		} else {
			errtxt.setText("Enter a valid date");
			return;
		}
	}

	public void start(Stage primaryStage) throws Exception {
		Delivery = false;
		Parent root = FXMLLoader.load(getClass().getResource("/gui/DeliveryInfoFXML.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("Delivery Info");
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		// phone number text field accept only number
		phonenumbertxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\d{0,10}?")) {
					phonenumbertxt.setText(oldValue);
				}
			}
		});

		// name text field accept only characters
		nametxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\sa-zA-Z*")) {
					nametxt.setText(newValue.replaceAll("[^\\sa-zA-Z]", ""));
				}
			}
		});

		// initialize hours from 0-23
		int i;
		for (i = 0; i < 24; i++) {
			if (i < 10)
				hourtxt.getItems().add("0" + String.valueOf(i));
			else
				hourtxt.getItems().add(String.valueOf(i));
		}
		// initialize minutes from 0-59
		for (i = 0; i < 60; i++) {
			if (i < 10)
				minutetxt.getItems().add("0" + i);
			else
				minutetxt.getItems().add(String.valueOf(i));
		}

		// initialize delivery types
		deliverytxt.getItems().add("Basic 25$");
		if (ChatClient.user.getUserType().equals("Bussiness"))
			deliverytxt.getItems().add("Shared");
		deliverytxt.getItems().add("Robot");

		// if user is not business type set invisible
		if (ChatClient.user.getUserType().equals("Normal")) {
			partnerstxt.setVisible(false);
			partnersSpinner.setVisible(false);
		}\

		deliverytxt.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
			if (newValue.equals("Shared")) {
				deliveryType = "Shared";
				partnerstxt.setVisible(true);
				partnersSpinner.setVisible(true);
				sharedtxt.setVisible(true);
				SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 20,
						0);
				partnersSpinner.setValueFactory(valueFactory);

			} else {
				deliveryType = newValue;
				partnerstxt.setVisible(false);
				sharedtxt.setVisible(false);
				partnersSpinner.setVisible(false);
			}
		});

		// set shared group delivery prices according to number of people picked
		partnersSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {

			switch (partnersSpinner.getValue().intValue()) {
			case 0:
				sharedtxt.setText("25");
				break;
			case 1:
				sharedtxt.setText("20$");
				break;
			case 2:
				sharedtxt.setText("15$");
				break;
			case 3:
				sharedtxt.setText("15$");
				break;
			default:
				sharedtxt.setText("15$");
				break;
			}
		});

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 01:51:31.759
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:51:31.759
!MESSAGE offset 8366, count -896, length 8498
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:51:31.759
!MESSAGE offset 8366, count -896, length 8498
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 01:51:31.760
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:51:31.760
!MESSAGE offset 8366, count -896, length 8498
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8366, count -896, length 8498
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.parseCheck(DiagnoseParser.java:2029)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.checkPrimaryDistance(DiagnoseParser.java:764)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.primaryPhase(DiagnoseParser.java:581)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:498)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14010)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13152)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:225)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:1138)
	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:11825)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1058)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 01:51:34.264
!MESSAGE Exception occurred during problem detection:
----------------------------------- SOURCE BEGIN -------------------------------------
package gui;

import java.net.URL;
import java.text.SimpleDateFormat;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Random;
import java.util.ResourceBundle;
import common.Delivery;
import common.GroupDelivery;
import common.Messages;
import common.MessagesClass;
import client.ChatClient;
import client.ClientUI;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.ComboBox;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class DeliveryInfoController implements Initializable {
	@FXML
	private DatePicker datetxt;

	@FXML
	private TextField nametxt;

	@FXML
	private TextField adresstxt;

	@FXML
	private TextField phonenumbertxt;

	@FXML
	private ComboBox<String> deliverytxt;

	@FXML
	private TextArea opentxt;

	@FXML
	private ComboBox<String> hourtxt;

	@FXML
	private ComboBox<String> minutetxt;

	@FXML
	private Text errtxt;

	@FXML
	private Spinner<Integer> partnersSpinner;

	@FXML
	private Text partnerstxt;

	@FXML
	private Text sharedtxt;

	public static boolean Delivery;

	public static String deliveryType;

	public static Delivery del;

	public static int randGroup;

	public static GroupDelivery gp;

	@FXML
	// go back to choose delivery type option
	void BackBtn(ActionEvent event) {
		Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
		stage.close();
		Stage primaryStage = new Stage();
		TypeOfOrderController TOOC = new TypeOfOrderController();
		try {
			TOOC.start(primaryStage);
		} catch (Exception e1) {
			e1.printStackTrace();
		}
	}

	@FXML
	// go to payment page
	void goToPayment(ActionEvent event) throws Exception {
		// if any field left empty pops a message to user
		if (nametxt.getText().equals("") || adresstxt.getText().equals("") || phonenumbertxt.getText().equals("")
				|| datetxt.getValue() == (null) || deliverytxt.getSelectionModel().isEmpty()
				|| hourtxt.getSelectionModel().isEmpty() || minutetxt.getSelectionModel().isEmpty()) {
			errtxt.setText("  Enter details");
			return;
		}

		// take current date and hour
		SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date(); // given date
		Calendar calendar = GregorianCalendar.getInstance(); // creates a new calendar instance
		calendar.setTime(date); // assigns calendar to given date
		int hours = calendar.get(Calendar.HOUR_OF_DAY); // gets hour in 24h format
		int minutes = calendar.get(Calendar.MINUTE);

		// take picked date and hour from user
		String pickedDate = datetxt.getValue().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		Date CurrentDate = sdformat.parse(NormalUserHomePageController.sClock);
		Date picked_Date = sdformat.parse(pickedDate);
		int hour = Integer.parseInt(hourtxt.getValue());
		int minute = Integer.parseInt(minutetxt.getValue());

		// check if picked date and hour is legal
		if ((hours < hour && CurrentDate.compareTo(picked_Date) == 0)
				|| (minutes < minute && hours == hour && CurrentDate.compareTo(picked_Date) == 0)
				|| CurrentDate.compareTo(picked_Date) < 0) {
			Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();
			stage.close();
			Stage primaryStage = new Stage();
			if (ChatClient.user.getUserType().equals("Normal") || (ChatClient.user.getUserType().equals("Bussiness")
					&& !deliverytxt.getValue().equals("Shared"))) {
				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}

			// check if business user picked shared delivery option
			// if yes -> generate random number between 10000-99999 of the group so that
			// other users can join
			// save number of group and size to the data base
			else if ((ChatClient.user.getUserType().equals("Bussiness") && deliverytxt.getValue().equals("Shared"))
					&& partnersSpinner.getValue().intValue() > 0) {

				Random r = new Random();
				randGroup = r.nextInt(99999 - 10000) + 10000;
				ChatClient.numCode = randGroup;
				gp = new GroupDelivery(randGroup, partnersSpinner.getValue().intValue());
				MessagesClass msg = new MessagesClass(Messages.partnersGroupNumber, gp);

				ClientUI.chat.accept(msg);

				Delivery = true;
				del = new Delivery(nametxt.getText(), phonenumbertxt.getText(), adresstxt.getText(),
						deliverytxt.getValue(), datetxt.getValue().toString(), hourtxt.getValue(), minutetxt.getValue(),
						opentxt.getText(), 0);
				PaymentNormalUserController PNUC = new PaymentNormalUserController();
				PNUC.start(primaryStage);
			}
		} else {
			errtxt.setText("Enter a valid date");
			return;
		}
	}

	public void start(Stage primaryStage) throws Exception {
		Delivery = false;
		Parent root = FXMLLoader.load(getClass().getResource("/gui/DeliveryInfoFXML.fxml"));
		Scene scene = new Scene(root);
		primaryStage.setTitle("Delivery Info");
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		// phone number text field accept only number
		phonenumbertxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\d{0,10}?")) {
					phonenumbertxt.setText(oldValue);
				}
			}
		});

		// name text field accept only characters
		nametxt.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!newValue.matches("\\sa-zA-Z*")) {
					nametxt.setText(newValue.replaceAll("[^\\sa-zA-Z]", ""));
				}
			}
		});

		// initialize hours from 0-23
		int i;
		for (i = 0; i < 24; i++) {
			if (i < 10)
				hourtxt.getItems().add("0" + String.valueOf(i));
			else
				hourtxt.getItems().add(String.valueOf(i));
		}
		// initialize minutes from 0-59
		for (i = 0; i < 60; i++) {
			if (i < 10)
				minutetxt.getItems().add("0" + i);
			else
				minutetxt.getItems().add(String.valueOf(i));
		}

		// initialize delivery types
		deliverytxt.getItems().add("Basic 25$");
		if (ChatClient.user.getUserType().equals("Bussiness"))
			deliverytxt.getItems().add("Shared");
		deliverytxt.getItems().add("Robot");

		// if user is not business type set invisible
		\
			partnerstxt.setVisible(false);
			partnersSpinner.setVisible(false);
		}\\

		deliverytxt.getSelectionModel().selectedItemProperty().addListener((options, oldValue, newValue) -> {
			if (newValue.equals("Shared")) {
				deliveryType = "Shared";
				partnerstxt.setVisible(true);
				partnersSpinner.setVisible(true);
				sharedtxt.setVisible(true);
				SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.IntegerSpinnerValueFactory(0, 20,
						0);
				partnersSpinner.setValueFactory(valueFactory);

			} else {
				deliveryType = newValue;
				partnerstxt.setVisible(false);
				sharedtxt.setVisible(false);
				partnersSpinner.setVisible(false);
			}
		});

		// set shared group delivery prices according to number of people picked
		partnersSpinner.valueProperty().addListener((obs, oldValue, newValue) -> {

			switch (partnersSpinner.getValue().intValue()) {
			case 0:
				sharedtxt.setText("25");
				break;
			case 1:
				sharedtxt.setText("20$");
				break;
			case 2:
				sharedtxt.setText("15$");
				break;
			case 3:
				sharedtxt.setText("15$");
				break;
			default:
				sharedtxt.setText("15$");
				break;
			}
		});

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 01:51:34.264
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:51:34.265
!MESSAGE offset 8315, count -896, length 8447
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:51:34.265
!MESSAGE offset 8315, count -896, length 8447
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 01:51:34.265
!MESSAGE Error in JDT Core during reconcile
!STACK 1
Java Model Exception: java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:324)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	... 19 more
Caused by: java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SUBENTRY 1 org.eclipse.jdt.core 4 1005 2021-12-28 01:51:34.265
!MESSAGE offset 8315, count -896, length 8447
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:1048)
	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:192)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-28 01:51:34.269
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:11395)
	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:850)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:394)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1173)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-28 01:51:34.270
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.StringIndexOutOfBoundsException: offset 8315, count -896, length 8447
	at java.base/java.lang.String.checkBoundsOffCount(String.java:4586)
	at java.base/java.lang.String.rangeCheck(String.java:304)
	at java.base/java.lang.String.<init>(String.java:300)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:5491)
	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1461)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.readTokenFromScanner(LexStream.java:84)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.token(LexStream.java:154)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream.kind(LexStream.java:194)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.secondaryPhase(DiagnoseParser.java:1592)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.errorRecovery(DiagnoseParser.java:503)
	at org.eclipse.jdt.internal.compiler.parser.diagnose.DiagnoseParser.diagnoseParse(DiagnoseParser.java:382)
	at org.eclipse.jdt.internal.compiler.parser.Parser.reportSyntaxErrors(Parser.java:14004)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:12857)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13051)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13008)
	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:11395)
	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:850)
	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:394)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1173)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:714)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1205)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2021-12-28 02:45:03.215 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-28 02:45:04.991
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.789
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:45:16.790
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-28 02:45:17.837
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-28 02:45:17.837
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58e2af93,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@204beb58,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-28 02:45:23.856
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-28 02:48:05.079
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-28 02:50:30.499
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)
!SESSION 2021-12-28 02:57:04.040 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-28 02:57:05.832
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.565
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 02:57:09.566
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-28 02:57:10.707
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-28 02:57:10.707
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@252f00ba,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4667c6d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-28 02:57:14.163
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-28 12:31:07.088 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-28 12:31:40.684
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-28 12:31:44.285
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 12:31:44.286
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-28 12:31:45.570
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-28 12:31:45.570
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@515555b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58e2af93,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-28 12:31:49.715
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 16:25:11.690
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package server;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.ResourceBundle;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.MultiFormatWriter;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;
import com.mysql.cj.conf.ConnectionUrl.Type;

import client.ChatClient;
import javafx.fxml.Initializable;
import common.Addition;
import common.BranchManager;
import common.CEOuser;
import common.Category;
import common.Company;
import common.Delivery;
import common.GroupDelivery;
import common.HRUser;
import common.HistogramCEO;
import common.InComeReport;
import common.Item;
import common.ItemAddition;
import common.Menu;
import common.Normal;
import common.Order;
import common.OrdersReport;
import common.PDFList;
import common.PerformenceReport;
import common.RestaurantManager;
import common.RestaurantReport;
import common.Resturaunt;
import common.User;
import common.Visa;
import common.W4CBussiness;
import common.W4CNormal;
import common.BussinessUser;
import common.WorkerUser;

public class mysqlConnection implements Initializable {
	public static User user;
	public static User user1 = null;
	public static ArrayList<String> list;
	public static ArrayList<BussinessUser> requestsList;
	public static ArrayList<User> getlistofnormalaccount;
	public static ArrayList<User> usersfromBiteMeDB;
	public static ArrayList<Item> Itemss;
	public static ArrayList<Item> AllItems;
	public static ArrayList<Company> companys;
	public static ArrayList<Resturaunt> getAllresturaunt;
	public static RestaurantManager restaurantManager;
	public static WorkerUser WorkerUser;
	public static BranchManager branchManager;
	public static HRUser HRManager;
	public static Normal Normaluser;
	public static ArrayList<RestaurantReport> ReportList;
	public static ArrayList<RestaurantReport> ReportListForManager;
	public static Connection conn;
	public static Resturaunt Resturaunt;
	public static ArrayList<Normal> NormalUsersNotAccepted;
	public static BussinessUser BussinessUser;
	public static CEOuser CEOuser1;
	public static ArrayList<User> TakeAllUserThatNotConfiredyet;
	public static ArrayList<User> userfrombitemedata;
	public static ArrayList<Company> CompanyList;
	public static ArrayList<Order> AllOrder;
	public static ArrayList<Item> Allitemsoforders;
	public static ArrayList<ItemAddition> itemsandAddition;
	public static ArrayList<OrdersReport> ordersReport;
	public static ArrayList<InComeReport> incomearr;
	public static ArrayList<PerformenceReport> PerfReport;
	public static ArrayList<HistogramCEO> HistogramArray;
	public static User LoginUser;
	public static int ReportIDCounter = 1;

	@SuppressWarnings("deprecation")
	public static Connection connectToDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}

		try {
			String s1 = "jdbc:mysql://localhost/assignment3?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static Connection connectToBiteMeDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}
//		"jdbc:mysql://localhost/assigment2?serverTimezone=IST", "root","912000bashar"
		try {
			String s1 = "jdbc:mysql://localhost/biteme_data?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed To BiteMe DB");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static void updateW4CforBussiness(BussinessUser user) {
		PreparedStatement ps;

		try {
			ps = conn.prepareStatement("UPDATE assignment3.w4cbussiness SET money= ? WHERE IDuser = ?");
			ps.setDouble(1, user.getW4c().getMoney());
			ps.setString(2, user.getID());
			ps.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static boolean GetGroupNumber(int number) throws SQLException {
		ResultSet rs = null;
		String query = "select * from assignment3.group_delivery where code=" + number;
		Statement st;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(query);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return rs.next();
	}

	public static void InsertGroup(GroupDelivery gp) {
		String sql = "insert into assignment3.group_delivery (code,group_size) values (?,?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(sql);
			preparedStmt.setInt(1, gp.getGroupNum());
			preparedStmt.setInt(2, gp.getGroupSize());
			preparedStmt.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static void soldItems(Order solditems) {
		Statement st;
		ResultSet rs = null;
		String sql;
		int soldupdate = 0;
		int updatesold = 0;
		for (int i = 0; i < solditems.getItems().size(); i++) {
			String query2 = "select quantity from assignment3.menu where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and Item_ID=" + solditems.getItems().get(i).getItem_ID();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query2);
				if (rs.next() == true) {
					updatesold = rs.getInt(1);
					updatesold -= solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.menu SET quantity= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and Item_ID="
							+ solditems.getItems().get(i).getItem_ID();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, updatesold);
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}

			String query = "select Sold from assignment3.solditem where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and ItemID=" + solditems.getItems().get(i).getItem_ID()
					+ " and Month=" + solditems.getMonth() + " and Year=" + solditems.getYear();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query);
				if (rs.next() == true) {
					soldupdate = rs.getInt(1);
					soldupdate += solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.solditem SET Sold= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and ItemID="
							+ solditems.getItems().get(i).getItem_ID() + " and Month=" + solditems.getMonth()
							+ " and Year=" + solditems.getYear();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, soldupdate);
					preparedStmt.execute();

				} else {
					sql = "insert into assignment3.solditem (IDRestaurant,ItemID,Sold,Month,Year) values (?,?,?,?,?)";
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, solditems.getRes().getResturauntID());
					preparedStmt.setInt(2, solditems.getItems().get(i).getItem_ID());
					preparedStmt.setInt(3, solditems.getItems().get(i).getQuantity());
					preparedStmt.setInt(4, solditems.getMonth());
					preparedStmt.setInt(5, solditems.getYear());
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

	}

	public static void newDelivery(Delivery del) {
		String query = " insert into assignment3.delivery (deliveryNum,orderNum,name,phonenumber,address,deliveryType,deliveryDate,clientTxt)"
				+ " values (?, ?, ?, ?, ?, ?,?,?)";

		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, del.getDeliveryNum());
			preparedStmt.setInt(2, del.getOrderNum());
			preparedStmt.setString(3, del.getFirstname());
			preparedStmt.setString(4, del.getPhonenumber());
			preparedStmt.setString(5, del.getAddress());
			preparedStmt.setString(6, del.getDeliveryType());
			preparedStmt.setString(7, del.getDate() + " " + del.getHour() + ":" + del.getMinute());
			preparedStmt.setString(8, del.getClientText());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void newOrder(Order order) {
		String query = " insert into assignment3.order (orderNum,RestaurantID,userID,submitDate,totalPrice,pickupTime)"
				+ " values (?, ?, ?, ?, ?, ?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, order.getOrderNum());
			preparedStmt.setInt(2, order.getRes().getResturauntID());
			preparedStmt.setString(3, order.getUser().getID());
			preparedStmt.setString(4, order.getCurrentDateAndTime());
			preparedStmt.setDouble(5, order.getTotalPrice());
			preparedStmt.setString(6, order.getDate() + " " + order.getHour() + ":" + order.getMinute());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}

		query = "insert into assignment3.order_items (orderNum,item_ID,quantity) values(?,?,?)";
		try {
			for (int i = 0; i < order.getItems().size(); i++) {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, order.getOrderNum());
				preparedStmt.setInt(2, order.getItems().get(i).getItem_ID());
				preparedStmt.setInt(3, order.getItems().get(i).getQuantity());
				preparedStmt.execute();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void order_items_additions(Object itemAddition) {
		ArrayList<Item> item_addition = (ArrayList<Item>) itemAddition;
		String query = "insert into assignment3.order_item_addition (orderNum,item_ID,name) values (?,?,?)";

		for (Item i : item_addition) {
			try {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, i.getOrderNum());
				preparedStmt.setInt(2, i.getItem_ID());
				preparedStmt.setString(3, i.getAdditions_names());
				// preparedStmt.setInt(4, i.getIndex());
				preparedStmt.execute();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}

	public static int getOrderID() {
		Statement st;
		ResultSet rs = null;
		int orderNum = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order");
			if (rs.next()) {
				orderNum = rs.getInt(1);
				if (orderNum == 0)
					return orderNum;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order ORDER BY orderNum DESC LIMIT 1");
			if (rs.next()) {
				orderNum = rs.getInt(1);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return orderNum;
	}

	public static int getIND() {
		Statement st;
		ResultSet rs = null;
		int ind = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order_item_addition");
			if (rs.next()) {
				ind = rs.getInt(1);
				if (ind == 0)
					return ind;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order_item_addition ORDER BY ind DESC LIMIT 1");
			if (rs.next()) {
				ind = rs.getInt(4);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return ind;
	}

	public static void DeleteAllReports() throws SQLException {
		Statement ps = conn.createStatement();
		PreparedStatement st, st1, st2, st3;
		st = conn.prepareStatement("DELETE FROM assignment3.ordersreport");
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.reports");
		st1.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.quarterlypdf");
		st2.executeUpdate();
		st3 = conn.prepareStatement("DELETE FROM assignment3.incomereports");
		st3.executeUpdate();
	}

	public static ArrayList<PDFList> PDFLists() throws SQLException {
		System.out.println("First");
		ArrayList<PDFList> PDFListArray = new ArrayList<>();
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Sent='" + 1 + "'");
		while (rs1.next()) {
			PDFList P = new PDFList(rs1.getString(1), rs1.getInt(2), rs1.getString(3));
			PDFListArray.add(P);
		}
		return PDFListArray;
	}

	public static String SendPDFToCeo(String location, int year, String Months) throws SQLException {
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + Months + "'");
		if (rs1.next()) {
			String query = "update assignment3.quarterlypdf set Sent = ? where Location = ? and Year = ? and Month = ?";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, 1);
			preparedStmt.setString(2, location);
			preparedStmt.setInt(3, year);
			preparedStmt.setString(4, Months);
			preparedStmt.executeUpdate();
			return "Updated";
		}
		if (year > EchoServer.Year)
			return "NotPassed";
		if (year < 2021)
			return "NotOpend";
		return null;
	}

	public static void InsertPDFtoDB(int year, int month, String Location)
			throws SQLException, DocumentException, IOException {
		if (month % 3 != 0) {
			return;
		}
		System.out.println("Inserting Q");
		String StringMonth = null;
		ArrayList<PerformenceReport> PReport = new ArrayList<>();
		ArrayList<RestaurantReport> RReport = new ArrayList<>();
		GetReport(Location, month, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 1, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 2, year, "Performence");
		PReport.addAll(PerfReport);
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.restaurant where Location='" + Location + "'");
		while (rs2.next()) {
			int RestaurantID = rs2.getInt(1);
			RReport.addAll(GetReportForManager(RestaurantID, month - 2, year));
		}
		if (month == 12) {
			StringMonth = "10,11,12";
		}
		if (month == 9) {
			StringMonth = "7,8,9";
		}
		if (month == 6) {
			StringMonth = "4,5,6";
		}
		if (month == 3) {
			StringMonth = "1,2,3";
		}
		String str = Location + String.valueOf(year) + String.valueOf(month);
		Document DocPDF = CreatePDF(PReport, RReport, str);
		String query2 = " insert into assignment3.quarterlypdf (Location,Year,Month,PDF,Sent)"
				+ " values (?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
		preparedStmt2.setString(1, Location);
		preparedStmt2.setInt(2, year);
		preparedStmt2.setString(3, StringMonth);
		InputStream inputStream = new FileInputStream(new File("C:\\G5BiteMe\\Report" + str + ".pdf"));
		preparedStmt2.setBlob(4, inputStream);
		preparedStmt2.setInt(5, 0);
		preparedStmt2.execute();
	}

	public static Document CreatePDF(ArrayList<PerformenceReport> PReport, ArrayList<RestaurantReport> RReport,
			String LYM) throws DocumentException, IOException {
		Document doc = new Document();
		System.out.println("Creating PDF Arrays");
		System.out.println(PReport.toString());
		System.out.println(RReport.toString());
		PdfWriter.getInstance(doc, new FileOutputStream("C:\\G5BiteMe\\Report" + LYM + ".pdf"));
		doc.open();
		PdfPTable tablepdf = new PdfPTable(5);
		tablepdf.addCell("Order ID");
		tablepdf.addCell("Restaurant Name");
		tablepdf.addCell("Order Time");
		tablepdf.addCell("Arrival Time");
		tablepdf.addCell("Condition");
		for (int i = 0; i < PReport.size(); i++) {
			int OrderID = PReport.get(i).getOrderID();
			String StringOrderID = String.valueOf(OrderID);
			String RName = PReport.get(i).getRestaurantName();
			Time OrderTime = PReport.get(i).getOrderTime();
			String OrderTimeString = String.valueOf(OrderTime);
			Time Arrival = PReport.get(i).getArrival();
			String ArrivalString = String.valueOf(Arrival);
			String Condition = PReport.get(i).getCondition();
			tablepdf.addCell(StringOrderID);
			tablepdf.addCell(RName);
			tablepdf.addCell(OrderTimeString);
			tablepdf.addCell(ArrivalString);
			tablepdf.addCell(Condition);
		}
		doc.add(tablepdf);
		doc.newPage();
		PdfPTable tablepdf1 = new PdfPTable(6);
		tablepdf1.addCell("Item ID");
		tablepdf1.addCell("Item Name");
		tablepdf1.addCell("Quantity");
		tablepdf1.addCell("Price per one");
		tablepdf1.addCell("Sold");
		tablepdf1.addCell("InCome");

		for (int i = 0; i < RReport.size(); i++) {
			int ItemID = RReport.get(i).getItemID();
			String StringItemID = String.valueOf(ItemID);
			String ItemName = RReport.get(i).getItemName();
			String Quantity = String.valueOf(RReport.get(i).getQuantity());
			String PerOne = String.valueOf(RReport.get(i).getPrice1());
			String Sold = String.valueOf(RReport.get(i).getSold());
			String InCome = String.valueOf(RReport.get(i).getInCome());

			tablepdf1.addCell(StringItemID);
			tablepdf1.addCell(ItemName);
			tablepdf1.addCell(Quantity);
			tablepdf1.addCell(PerOne);
			tablepdf1.addCell(Sold);
			tablepdf1.addCell(InCome);
		}
		doc.add(tablepdf1);
		doc.close();
		return doc;
	}

	public static String GetHistogram(String area, int year1, String months) throws SQLException {
		HistogramArray = new ArrayList<HistogramCEO>();
		boolean flag = false;
		int month1 = 0;
		int month3 = 0;
		if (months.equals("1,2,3")) {
			month1 = 1;
			month3 = 3;
		}
		if (months.equals("4,5,6")) {
			month1 = 4;
			month3 = 6;
		}
		if (months.equals("7,8,9")) {
			month1 = 7;
			month3 = 9;
		}
		if (months.equals("10,11,12")) {
			month1 = 10;
			month3 = 12;
		}
		if (month3 > EchoServer.Month && year1 == EchoServer.Year) {
			return "NotPassed";
		}
		if (year1 > EchoServer.Year) {
			return "NotPassed";
		}
		if (month3 < 10 && year1 == 2021) {
			return "NotOpend";
		}
		if (year1 < 2021) {
			return "NotOpend";
		}
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
				+ "' and Month>='" + month1 + "' and Month <='" + month3 + "' and Year='" + year1 + "'");
		while (rs2.next()) {
			String type = rs2.getString(1);
			if (type.equals("InCome")) {
				flag = false;
				int ID = rs2.getInt(5);
				String month = rs2.getString(4);
				Statement stmt3;
				stmt3 = conn.createStatement();
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs3.next()) {
					String RestaurantName = rs3.getString(2);
					double InCome = rs3.getDouble(3);
					HistogramCEO ceo = new HistogramCEO(RestaurantName, InCome, 0);
					for (int i = 0; i < HistogramArray.size(); i++) {
						if (HistogramArray.get(i).getRestaurantName().equals(ceo.getRestaurantName())) {
							flag = true;
							double a = HistogramArray.get(i).getInCome();
							HistogramArray.get(i).setInCome(InCome + a);
						}
					}
					if (!flag) {
						HistogramArray.add(ceo);
					}
				}
				Statement stmt4;
				stmt4 = conn.createStatement();
				String ord = "Order";
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
						+ "' and Month='" + month + "' and Year='" + year1 + "' and Type='" + ord + "'");
				if (rs4.next()) {
					int ordID = rs4.getInt(5);
					Statement stmt5;
					stmt5 = conn.createStatement();
					ResultSet rs5 = stmt5
							.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ordID + "'");
					while (rs5.next()) {
						String RN = rs5.getString(2);
						int b = rs5.getInt(4);
						System.out.println("Printing B");
						System.out.println(b);
						for (int i = 0; i < HistogramArray.size(); i++) {
							if (HistogramArray.get(i).getRestaurantName().equals(RN)) {
								int a = HistogramArray.get(i).getSold();
								System.out.println("Printing a");
								System.out.println(a);
								HistogramArray.get(i).setSold(a + b);
								System.out.println("END");
								System.out.println(HistogramArray.get(i).getSold());
							}
						}
					}
				}
			}
		}
		return "Done";

	}

	public static String GetReport(String location, int month, int year, String type) throws SQLException {
		boolean flag = false;
		if (year > EchoServer.Year) {
			return "NotPassed";
		}
		if (month > EchoServer.Month && year == EchoServer.Year) {
			return "NotPassed";
		}
		incomearr = new ArrayList<InComeReport>();
		ordersReport = new ArrayList<OrdersReport>();
		PerfReport = new ArrayList<PerformenceReport>();
		Statement stmt;
		Statement stmt5;
		stmt = conn.createStatement();
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.reports where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + month + "' and Type ='" + type + "'");
		while (rs1.next() == true) {
			flag = true;
			if (type.equals("InCome")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs2.next() == true) {
					InComeReport income = new InComeReport(rs2.getString(2), rs2.getDouble(3));
					incomearr.add(income);
				}
				System.out.println(incomearr.toString());
			}
			if (type.equals("Order")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ID + "'");
				while (rs2.next() == true) {
					OrdersReport orderReport = new OrdersReport(rs2.getString(2), rs2.getString(3), rs2.getInt(4));
					ordersReport.add(orderReport);
				}
				System.out.println(ordersReport.toString());
			}
		}
		if (flag) {
			return "Done";
		}
		if (type.equals("Performence")) {
			stmt5 = conn.createStatement();
			ResultSet rs11 = stmt5
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs11.next()) {
				flag = true;
				String ResName = rs11.getString(2);
				stmt = conn.createStatement();
				ResultSet rs12 = stmt.executeQuery("SELECT * FROM assignment3.performencereports where RestaurantName='"
						+ ResName + "' and Year='" + year + "' and Month ='" + month + "'");
				while (rs12.next()) {
					Time order = rs12.getTime(3);
					Time arrival = rs12.getTime(4);
					int Diff = order.compareTo(arrival);
					if (Diff == 1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Early");
						PerfReport.add(perf);
					}
					if (Diff == 0) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Exactly");
						PerfReport.add(perf);
					}
					if (Diff == -1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Late");
						PerfReport.add(perf);
					}
				}
			}

		}
		System.out.println(PerfReport);
		if (PerfReport.size() == 0 && flag == true) {
			return "NotOpened";
		}
		if (flag) {
			return "Done";
		}
		return "NotOpened";
	}

	static void CreateInComeReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		incomearr = new ArrayList<InComeReport>();
		double income = 0;
		try {
			Statement stmt1 = conn.createStatement();
			Statement stmt2 = conn.createStatement();
			Statement stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				income = 0;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int ItemID = Integer.parseInt(rs2.getString(2));
					int sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						income += sold * rs3.getDouble(3);
					}
				}
				InComeReport ICR = new InComeReport(RestaurantName, income);
				incomearr.add(ICR);
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "InCome");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < incomearr.size(); i++) {
				String query1 = " insert into assignment3.incomereports (ID,RestaurantName,InCome)"
						+ " values (?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, incomearr.get(i).getRestaurantName());
				preparedStmt1.setDouble(3, incomearr.get(i).getIncome());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}

	static void CreateOrdersReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		boolean flag2 = false;
		Statement stmt1;
		Statement stmt2;
		Statement stmt3;
		ordersReport = new ArrayList<OrdersReport>();
		try {
			stmt1 = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int sold = rs2.getInt(3);
					int ItemID = Integer.parseInt(rs2.getString(2));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						String Catalog = rs3.getString(4);
						OrdersReport Order = new OrdersReport(RestaurantName, Catalog, sold);
						for (int i = 0; i < ordersReport.size(); i++) {
							if (ordersReport.get(i).getRestaurantName().equals(Order.getRestaurantName())
									&& ordersReport.get(i).getCatalog().equals(Order.getCatalog())) {
								ordersReport.get(i).setSold(ordersReport.get(i).getSold() + Order.getSold());
								flag2 = true;
							}
						}
						if (!flag2)
							ordersReport.add(Order);
						flag2 = false;
					}
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "Order");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < ordersReport.size(); i++) {
				String query1 = " insert into assignment3.ordersreport (ID,RestaurantName,Catalog,Sold)"
						+ " values (?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, ordersReport.get(i).getRestaurantName());
				preparedStmt1.setString(3, ordersReport.get(i).getCatalog());
				preparedStmt1.setInt(4, ordersReport.get(i).getSold());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}
/////////////////////////////////////////////////////////////////

	public static void insidealldatafromBiteMeDB() throws SQLException {
		userfrombitemedata = new ArrayList<User>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From biteme_data.users");
		User user = null;
		while (RS.next()) {
			try {
				user = new User(RS.getString(1), RS.getString(4), RS.getString(5), RS.getString(8), RS.getString(2),
						RS.getString(6), RS.getString(7), RS.getString(3), RS.getString(14), RS.getString(13), 0,
						Integer.parseInt(RS.getString(11)), RS.getString(12), Integer.parseInt(RS.getString(10)),
						Integer.parseInt(RS.getString(15)));
				userfrombitemedata.add(user);
				String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
						+ " values (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setString(1, user.getID());
				preparedStmt.setString(2, user.getUserName());
				preparedStmt.setString(3, user.getPassword());
				preparedStmt.setString(4, user.getUserType());
				preparedStmt.setInt(5, 0);
				preparedStmt.setInt(6, user.getConfirm());
				preparedStmt.setString(7, user.getStatus());
				preparedStmt.execute();
			} catch (Exception e) {
				System.out.println("importing data ...");
			}
			switch (user.getUserType()) {
			case "BranchManager":
				String query1 = " insert into assignment3.branchmanager (ID,FirstName,LastName,Email,PhoneNumber,location)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setString(1, user.getID());
				preparedStmt1.setString(2, user.getFirstname());
				preparedStmt1.setString(3, user.getLastname());
				preparedStmt1.setString(4, user.getEmail());
				preparedStmt1.setString(5, user.getPhonenumber());
				preparedStmt1.setString(6, user.getLocation());
				preparedStmt1.execute();
				break;
			case "Normal":
				String query2 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
				preparedStmt2.setString(1, user.getID());
				preparedStmt2.setString(2, user.getFirstname());
				preparedStmt2.setString(3, user.getLastname());
				preparedStmt2.setString(4, user.getEmail());
				preparedStmt2.setString(5, user.getPhonenumber());
				preparedStmt2.setInt(6, user.getVisaavailable());
				preparedStmt2.execute();
				break;
			case "Bussiness":
				String query3 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt3 = conn.prepareStatement(query3);
				preparedStmt3.setString(1, user.getID());
				preparedStmt3.setString(2, user.getFirstname());
				preparedStmt3.setString(3, user.getLastname());
				preparedStmt3.setString(4, user.getEmail());
				preparedStmt3.setString(5, user.getPhonenumber());
				preparedStmt3.setString(6, user.getCompany());
				preparedStmt3.execute();
				break;
			case "CEO":
				String query4 = " insert into assignment3.ceouser (ID,FirstName,LastName,Email,PhoneNumber)"
						+ " values (?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
				preparedStmt4.setString(1, user.getID());
				preparedStmt4.setString(2, user.getFirstname());
				preparedStmt4.setString(3, user.getLastname());
				preparedStmt4.setString(4, user.getEmail());
				preparedStmt4.setString(5, user.getPhonenumber());
				preparedStmt4.execute();
				break;
			case "RestaurantManager":
				String query5 = " insert into assignment3.restaurantmanager (ID,FirstName,LastName,Email,PhoneNumber,IDRestaurant)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt5 = conn.prepareStatement(query5);
				preparedStmt5.setString(1, user.getID());
				preparedStmt5.setString(2, user.getFirstname());
				preparedStmt5.setString(3, user.getLastname());
				preparedStmt5.setString(4, user.getEmail());
				preparedStmt5.setString(5, user.getPhonenumber());
				preparedStmt5.setInt(6, user.getIdrestaurant());
				preparedStmt5.execute();
				break;
			case "HR":
				Statement stmt;
				String query6 = " insert into assignment3.hruser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
				preparedStmt6.setString(1, user.getID());
				preparedStmt6.setString(2, user.getFirstname());
				preparedStmt6.setString(3, user.getLastname());
				preparedStmt6.setString(4, user.getEmail());
				preparedStmt6.setString(5, user.getPhonenumber());
				preparedStmt6.setString(6, user.getCompany());
				preparedStmt6.execute();

				break;
			case "Worker":
				String query7 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt7 = conn.prepareStatement(query7);
				preparedStmt7.setString(1, user.getID());
				preparedStmt7.setString(2, user.getFirstname());
				preparedStmt7.setString(3, user.getLastname());
				preparedStmt7.setString(4, user.getEmail());
				preparedStmt7.setString(5, user.getPhonenumber());
				preparedStmt7.setInt(6, user.getIdrestaurant());
				preparedStmt7.execute();

				break;
			}
		}
	}

	public static void deletealldata() throws SQLException {
		Statement ps = conn.createStatement();

		PreparedStatement st, st1, st2 = null, st3 = null;

		ResultSet rs = ps.executeQuery("SELECT * FROM assignment3.users where confirm=0");
		while (rs.next() == true) {
			String ID = rs.getString(1);
			String type = rs.getString(4);

			if (type.equals("Normal")) {
				st = conn.prepareStatement("DELETE FROM assignment3.normaluser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("Bussiness")) {
				st = conn.prepareStatement("DELETE FROM assignment3.bussinessuser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("BranchManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.branchmanager");
				st.executeUpdate();
			} else if (type.equals("CEO")) {
				st = conn.prepareStatement("DELETE FROM assignment3.ceouser");
				st.executeUpdate();
			} else if (type.equals("RestaurantManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantmanager");
				st.executeUpdate();
			} else if (type.equals("HR")) {
				st = conn.prepareStatement("DELETE FROM assignment3.hruser");
				st.executeUpdate();
			} else if (type.equals("Worker")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker");
				st.executeUpdate();
			}
		}
		st = conn.prepareStatement("DELETE FROM assignment3.users WHERE confirm = ?");
		st.setInt(1, 0);
		st.executeUpdate();
	}

	// public WorkerUser(String userID, String firstName, String lastName, String
	// userName, String password, String email,
	// String phoneNumber, int iDRestaurant) {
	public static void LogOutAllAccounts() throws SQLException {
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? ");
		ps.setInt(1, 0);
		ps.executeUpdate();
	}

	public static String AddNewUser(User user, Object msgData1, String table) throws SQLException {
		PreparedStatement st;
		try {
			Statement stmt = conn.createStatement();

			ResultSet rs1 = stmt
					.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			ResultSet rs3 = stmt.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs3.next() == true) {
				return "IDAlreadyExists";
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		if (table.equals("normaluser")) {
			W4CNormal w4c = (W4CNormal) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, user.getID());
			preparedStmt1.setString(2, user.getFirstname());
			preparedStmt1.setString(3, user.getLastname());
			preparedStmt1.setString(4, user.getEmail());
			preparedStmt1.setString(5, user.getPhonenumber());
			preparedStmt1.setInt(6, user.getVisaavailable());
			preparedStmt1.execute();

			String query6 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
			preparedStmt6.setString(1, code);
			preparedStmt6.setString(2, w4c.getUser().getID());
			preparedStmt6.execute();

		} else {
			W4CBussiness w4c = (W4CBussiness) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query2 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, user.getID());
			preparedStmt2.setString(2, user.getFirstname());
			preparedStmt2.setString(3, user.getLastname());
			preparedStmt2.setString(4, user.getEmail());
			preparedStmt2.setString(5, user.getPhonenumber());
			preparedStmt2.setString(6, user.getCompany());
			preparedStmt2.execute();

			String query4 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
			preparedStmt4.setString(1, code);
			preparedStmt4.setDouble(2, w4c.getMoney());
			preparedStmt4.setString(3, w4c.getUser().getID());
			preparedStmt4.execute();

		}
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? , UserType=? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, user.getUserType());
		ps.setString(4, user.getID());
		ps.executeUpdate();

		return "updated";
	}

	public static String AddNewUserwithvisa(User user, Object msgData1, Visa visa, String table) throws SQLException {
		String str = AddNewUser(user, msgData1, table);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.normaluser SET VisaIsAvailable= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, user.getID());
		ps.executeUpdate();

		return str;
	}

	public static void confirmCompane(String cname) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where companyname='" + cname + "'");
		if (rs.next() != true) {
			String query1 = " insert into assignment3.company (companyname,confirm)" + " values (?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, cname);
			preparedStmt1.setInt(2, 0);
			preparedStmt1.execute();
		}
	}

	public static void companyConfirm(String cname) throws SQLException {
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.company SET confirm= ? WHERE companyname = ?");
		ps.setInt(1, 1);
		ps.setString(2, cname);
		ps.executeUpdate();
	}

	public static ArrayList<Company> getCompanyList() {
		Statement stmt;
		CompanyList = new ArrayList<Company>();
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where confirm='" + 0 + "'");
			while (rs.next() == true) {
				Company company = new Company(rs.getString(1), rs.getInt(2));
				CompanyList.add(company);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return CompanyList;
	}

	public static ArrayList<User> TakeAllUserThatNotConfiredyet() throws SQLException {
		TakeAllUserThatNotConfiredyet = new ArrayList<>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From assignment3.users where UserType= 'null'");
		User users;
		while (RS.next()) {
			String id = RS.getString(1);

			for (int i = 0; i < userfrombitemedata.size(); i++) {
				if (id.equals(userfrombitemedata.get(i).getID())) {
					TakeAllUserThatNotConfiredyet.add(userfrombitemedata.get(i));
				}
			}
		}
		return TakeAllUserThatNotConfiredyet;
	}

	public static ArrayList<Company> GetallAvailableCompany() throws SQLException {
		companys = new ArrayList<Company>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.company where confirm=1");
		Company company;
		while (RS.next()) {
			company = new Company(RS.getString(1), Integer.parseInt(RS.getString(2)));
			companys.add(company);
		}
		return companys;

	}

	///////////////
	public static ArrayList<Order> GetAllOrder(int id) throws NumberFormatException, SQLException {
		AllOrder = new ArrayList<Order>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.order where RestaurantID='" + id + "'");
		Order order;
		while (RS.next()) {
			order = new Order(Integer.parseInt(RS.getString(1)), Double.parseDouble(RS.getString(5)), RS.getString(4),
					RS.getString(6), RS.getString(3));
			AllOrder.add(order);
		}
		return AllOrder;
	}

	/////////////////////
	public static void UpdateItem(Item item, String str) throws SQLException {
		PreparedStatement ps, ps1;
		ps1 = conn.prepareStatement("UPDATE assignment3.menu SET quantity= ? WHERE Item_ID = ?");
		ps1.setInt(1, item.getQuantity());
		ps1.setInt(2, item.getItem_ID());
		ps1.executeUpdate();
		ps = conn.prepareStatement("UPDATE assignment3.item SET Item_name= ?, Item_price=? WHERE Item_ID = ?");
		ps.setString(1, item.getItem_Name());
		ps.setDouble(2, item.getPrice());
		ps.setInt(3, item.getItem_ID());
		ps.executeUpdate();

	}

//////////////////
	public static void RemoveItem(Item item) throws SQLException {
		PreparedStatement st, st1;
		st1 = conn.prepareStatement("DELETE FROM assignment3.menu WHERE Item_ID = ?");
		st1.setInt(1, item.getItem_ID());
		st1.executeUpdate();
		st = conn.prepareStatement("DELETE FROM assignment3.item WHERE Item_ID = ?");
		st.setInt(1, item.getItem_ID());
		st.executeUpdate();

	}

	//////////////////
	public static void RemoveItemAddition(Item item, String addition) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.item_addition WHERE name=? and Item_ID = ?");
		st.setString(1, addition);
		st.setInt(2, item.getItem_ID());
		st.executeUpdate();

		st1 = conn.prepareStatement("DELETE FROM assignment3.addition WHERE name = ?");
		st1.setString(1, addition);
		st1.executeUpdate();

	}

	/////////////////
	public static void AddItems(Item item, Addition addition, int resid, String str) throws SQLException {
		if (addition == null) {
			String query = " insert into assignment3.item (item_ID,Item_name,Item_price,category)"
					+ " values (?, ?,?,?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, item.getItem_ID());
			preparedStmt.setString(2, item.getItem_Name());
			preparedStmt.setDouble(3, item.getPrice());
			preparedStmt.setString(4, str);
			preparedStmt.execute();
			String query1 = " insert into assignment3.menu (IDRestaurant,item_ID,quantity)" + " values (?, ?,?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setInt(1, resid);
			preparedStmt1.setInt(2, item.getItem_ID());
			preparedStmt1.setInt(3, item.getQuantity());
			preparedStmt1.execute();
		} else {
			String query = " insert into assignment3.addition (name)" + " values (?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, addition.getName());
			preparedStmt.execute();
			String query2 = " insert into assignment3.item_addition (item_ID,name)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setInt(1, item.getItem_ID());
			preparedStmt2.setString(2, addition.getName());
			preparedStmt2.execute();

		}
	}

	public static ArrayList<WorkerUser> GetAllWorkers(int id) throws Exception// get all worker
	{
		ArrayList<WorkerUser> allworker = new ArrayList<WorkerUser>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		WorkerUser WorkerUser;
		ResultSet RS = ps
				.executeQuery("SELECT * From assignment3.restaurantworker where restaurantWorker='" + id + "'");
		while (RS.next()) {
			String idres = RS.getString(1);
			ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.users where ID='" + idres + "'");
			if (RS1.next()) {
				WorkerUser = new WorkerUser(RS1.getString(1), RS.getString(2), RS.getString(3), RS1.getString(2),
						RS1.getString(3), RS.getString(4), RS.getString(5), id);
				WorkerUser.setRestaurantName(getrestaurantname(id).getResturaunt_Name());
				allworker.add(WorkerUser);

			}
		}
		return allworker;
	}

	public static void UpdateStatusOfUsers(User user1) throws SQLException {
		// System.out.println("user status updated ...." + user1.getUserName());
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET status= ? WHERE ID = ?");
		ps.setString(1, user1.getStatus());
		ps.setString(2, user1.getID());
		ps.executeUpdate();

	}

	public static void BussinessAccountHasBeenAccepted(User user) throws SQLException {/// this method that accepted
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setString(1, "1");
		ps.setString(2, "Active");

		ps.setString(3, user.getID());
		ps.executeUpdate();
	}

	// add new business account
	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser, String str)
			throws SQLException {

		System.out.println("i am getting into login query");
		try {
			Statement stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}

			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, str);
			preparedStmt2.setFloat(2, bussinessUser.getW4C());
			preparedStmt2.setString(3, bussinessUser.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	// add new bussiness account with visa
	static String InsertNewBussinessAccountWithVisa(Visa visa, User user, BussinessUser bussinessUser, String str)
			throws SQLException {
		String value = InsertNewBussinessAccount(user, bussinessUser, str);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		return value;

	}

	static int IDForW4C() {
		Random rand = new Random();
		Statement stmt, stmt1;
		try {
			while (true) {
				int W4C = rand.nextInt((999 - 100) + 1) + 100;
				stmt = conn.createStatement();
				stmt1 = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cnormal where code= '" + W4C + "'");
				if (!rs.next()) {
					ResultSet rs1 = stmt
							.executeQuery("SELECT * FROM assignment3.w4cbussiness where code= '" + W4C + "'");
					if (!rs1.next()) {
						System.out.println(W4C);
						return W4C;
					}
				}
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return 5;
	}

//////////////////////
	public static void RefundCustomer(int number) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		stmt1= conn.createStatement();

		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.order where orderNum='"+number+"'");
		if (rs.next() == true) {
			String userid=rs.getString(3);
			ResultSet rs1= stmt1.executeQuery("SELECT * FROM assignment3.users where ID='"+userid+"'");
			if (rs1.next() == true) {
				String type=rs1.getString(4);
				if(type.equals("Bussiness"))
				{
					Double price=rs.getDouble(5);
					price*0.
				}
			}
		}
	}

	static String LogInChecker(User username) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where UserName='" + username.getUserName()
				+ "' and Password='" + username.getPassword() + "'");
		if (rs.next() == true) {
			if (rs.getInt(5) == 1)
				return "LoggedIn";

			if (rs.getString(7).equals("Locked")) {
				return "Locked";
			}
			LoginUser = new User(rs.getString(1), username.getUserName(), rs.getString(3), rs.getString(4),
					Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
			return "Entered";
		}
		return "NotExist";
	}

	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser) throws SQLException {
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	static User selectuserfromNormalUserTable(User username) {// check if the password and the user name is correct , if
		// yes then send the
// right message

		Statement stmt;
		int status;
		boolean valid = false;
		String usernameStatus;
		String Status;
		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + username.getID() + "'");
			if (rs.next() == true) {
				Status = rs.getString(10);
				user = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));

				usernameStatus = username.getUserName();
				status = rs.getInt("IsLoggedIn");
			}
			return user;

		} catch (SQLException e) {
			e.printStackTrace();
		}

		return null;

	}

	public static void AcceptNewNormalUser(User username) throws SQLException {
		System.out.println(username.getID());
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, username.getID());
		ps.executeUpdate();
	}

	public static void updateClientStatus(User user, int status) {
		System.out.println("user status updated ...." + user.getUserName());
		PreparedStatement ps, rs;
		try {
			ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? WHERE UserName = ?");
			ps.setInt(1, status);
			ps.setString(2, user.getUserName());

			if (ps.executeUpdate() != 0) {
				System.out.println("update " + user.getUserName() + " status to:" + status);

			} else {
				rs = conn.prepareStatement("UPDATE bitemeuser SET IsLoggedIn= ? WHERE UserName = ?");
				rs.setInt(1, status);
				rs.setString(2, user.getUserName());
				rs.executeUpdate();
			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static void deleteId(String id, String sqltable) throws SQLException {
		PreparedStatement st, st1, st2 = null, st3 = null;
		if (sqltable.equals("normaluser")) {
			st = conn.prepareStatement("DELETE FROM assignment3.normaluser WHERE ID = ?");
			st.setString(1, id);
			st.executeUpdate();
			st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
			st1.setString(1, id);
			st1.executeUpdate();
		}
		if (sqltable.equals("restaurant")) {
			st = conn.prepareStatement("DELETE FROM assignment3.restaurant WHERE IDRestaurant = ?");
			st.setInt(1, Integer.parseInt(id));
			st.executeUpdate();
		} else
			st3 = conn.prepareStatement("DELETE FROM assignment3.bussinessuser WHERE ID = ?");
		st3.setString(1, id);
		st3.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st2.setString(1, id);
		st2.executeUpdate();

	}

	static boolean getTheRequestList(String company) {
		requestsList = new ArrayList<BussinessUser>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps
					.executeQuery("SELECT * From assignment3.users where UserType='Bussiness' and status='Frozen'");
			BussinessUser request;
			while (RS.next()) {
				String id = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery(
						"SELECT * From assignment3.bussinessuser where ID='" + id + "'and Company='" + company + "'");
				if (RS1.next()) {
					request = new BussinessUser(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), 0, RS1.getString(6), 0);
					requestsList.add(request);

				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static boolean getAllUsers() {
		getlistofnormalaccount = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from assignment3.users where UserType= 'Normal' and confirm = 1");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				getlistofnormalaccount.add(request);
				System.out.print(getlistofnormalaccount);
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static void putdatafrombitemeDB() {////////////////////////////////////////////////////////////////////////// WTF
		usersfromBiteMeDB = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void isidedatafrombmtosassignment(ArrayList<User> user) {
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}
			System.out.print(usersfromBiteMeDB);

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void getAllResturaunt(String location) {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant where location='" + location + "'");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static void getAllResturaunt() {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static ArrayList<RestaurantReport> GetReportForManager(int restaurantID, int month, int year)
			throws SQLException {
		ReportListForManager = new ArrayList<RestaurantReport>();
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;
		int month2 = month + 2;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();
			ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='" + restaurantID
					+ "' and Month>='" + month + "' and Month <='" + month2 + "' and Year='" + year + "'");
			System.out.println("dd");
			while (rs2.next() == true) {
				System.out.println("jj");
				ItemID = Integer.parseInt(rs2.getString(2));
				sold = Integer.parseInt(rs2.getString(3));
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
				System.out.println(ItemID);
				System.out.println(restaurantID);
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='" + restaurantID
						+ "' and Item_ID= '" + ItemID + "'");
				if (rs4.next() == true) {
					quantity1 = Integer.parseInt(rs4.getString(3));
					System.out.println(quantity1);
				}
				while (rs3.next() == true) {
					System.out.println("tat");
					System.out.println("Babi");
					rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1, Float.parseFloat(rs3.getString(3)),
							sold, sold * Float.parseFloat(rs3.getString(3)));
					System.out.println("add");
					ReportListForManager.add(rsp);
					System.out.println("ZZZZ");
				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println(ReportListForManager);

		return ReportListForManager;
	}

	public static W4CBussiness getW4CBussiness(User user) {
		W4CBussiness w4c = null;
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cbussiness where IDuser=" + user.getID());
			if (rs.next()) {
				w4c = new W4CBussiness(rs.getInt(1), user, rs.getDouble(2));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return w4c;
	}

	static RestaurantManager GetRestaurantManager(User user) {
		Statement stmt, stmt1;
		int status;
		try {
			stmt1 = conn.createStatement();
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");

				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.restaurant where IDRestaurant='"
						+ Integer.parseInt(rs.getString(6)) + "'");
				if (rs1.next() == true) {
					restaurantManager = new RestaurantManager(rs.getString(1), rs.getString(2), rs.getString(3),
							rs.getString(4), rs.getString(5), Integer.parseInt(rs.getString(6)));
					System.out.println(restaurantManager);

					return restaurantManager;
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static void deleteOrder(int orderid) {
		Statement stmt;
		try {
			String SQL = "delete from assignment3.order where orderNum=?";
			PreparedStatement pstmt = null;

			// get a connection and then in your try catch for executing your delete...

			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_items where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_item_addition where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static boolean CheckDelivery(int orderid) {
		String sql = "select COUNT(*) from assignment3.delivery where orderNum=" + orderid;
		Statement st = null;
		try {
			st = conn.createStatement();
			ResultSet rs = st.executeQuery(sql);
			if (rs.next() == true) {
				String SQL = "delete from assignment3.delivery where orderNum=?";
				PreparedStatement pstmt = null;
				pstmt = conn.prepareStatement(SQL);
				pstmt.setInt(1, orderid);
				pstmt.executeUpdate();
				return true;
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	public static String GetDeliveryDate(int orderid) {
		Statement stmt;
		String date = "";
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("select * from assignment3.delivery where orderNum=" + orderid);
			date = rs.getString(6);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return date;
	}

	static WorkerUser GetRestaurantWorker(User user) {///////////////////////////////////////////
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantworker where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");
				WorkerUser = new WorkerUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return WorkerUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	private static String getitemname(int itemid) throws SQLException {
		Statement stmt, stmt1;
		stmt1 = conn.createStatement();
		String str = null;
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + itemid + "'");
		if (rs1.next() == true) {
			str = rs1.getString(2);

		}
		return str;
	}

/////////////////////////////////////
	public static ArrayList<ItemAddition> GetallOrederItems(int ordernum) throws SQLException {
		Statement stmt, stmt1;

		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ArrayList<ItemAddition> itemsandAddition1 = new ArrayList<>();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.order_item_addition where orderNum='" + ordernum + "'");
		while (rs.next()) {
			int itemid = rs.getInt(2);
			String str = rs.getString(3);
			ItemAddition a = (new ItemAddition(getitemname(itemid), str));
			itemsandAddition1.add(a);
		}
		System.out.print("****&****");
		System.out.print(itemsandAddition1);
		return itemsandAddition1;
	}

	public static String getuser(String id) throws SQLException {
		Statement stmt, stmt1;
		int status;
		String mail = null;
		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + id + "'");
		if (rs.next() == true) {
			String type = rs.getString(4);
			switch (type) {
			case "Normal":
				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + id + "'");
				if (rs1.next() == true) {
					mail = rs1.getString(4);
					return mail;
				}
				break;
			case "Bussiness":
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + id + "'");
				if (rs2.next() == true) {
					mail = rs2.getString(4);
					return mail;
				}
				break;

			}
		}
		return mail;
	}

	static BranchManager GetBranchManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.branchmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				branchManager = new BranchManager(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6));
				return branchManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static CEOuser CeoUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.ceouser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				CEOuser1 = new CEOuser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5));
				return CEOuser1;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static BussinessUser GetBissnessUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				W4CBussiness w4c = getW4CBussiness(user);
				BussinessUser = new BussinessUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6), w4c);
				return BussinessUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding BissessUser!!!");
		return null;
	}

	static Resturaunt getrestaurantname(int id) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT *  FROM assignment3.restaurant where IDRestaurant= " + id);
		if (rs.next() == true) {
			Resturaunt = new Resturaunt(Integer.parseInt(rs.getString(1)), rs.getString(2), rs.getString(3));
			return Resturaunt;
		}
		return null;

	}

	static HRUser GetHRManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.hruser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				HRManager = new HRUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(6));
				return HRManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static Normal getNormalUser(User user) throws SQLException {
		Normal nuser = null;

		Statement st;
		ResultSet rs = null;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("Select * from assignment3.normaluser where ID=" + user.getID());
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		if (rs.next()) {
			try {
				nuser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5));
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return nuser;

	}

	public static Normal Getnormaluser(User user) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				Normaluser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return Normaluser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;
	}

	public static ArrayList<RestaurantReport> GetReportForRestaurant(RestaurantManager restaurantManager, int month,
			int year) throws SQLException {
		ReportList = new ArrayList<RestaurantReport>();
		Statement stmt;
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;

		int IDRestaurant;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();

			System.out.println("aa");
			System.out.println(restaurantManager.getUserName());

			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.restaurantmanager where ID='" + restaurantManager.getUserID() + "'");
			System.out.println("bb");
			if (rs.next() == true) {
				System.out.println("cc");
				IDRestaurant = Integer.parseInt(rs.getString(6));
				System.out.println(IDRestaurant);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				System.out.println("dd");
				while (rs2.next() == true) {
					System.out.println("jj");
					ItemID = Integer.parseInt(rs2.getString(2));
					sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='"
							+ IDRestaurant + "' and Item_ID= '" + ItemID + "'");
					if (rs4.next() == true) {
						quantity1 = Integer.parseInt(rs4.getString(3));
						System.out.println(quantity1);
					}
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					System.out.println("mm");
					while (rs3.next() == true) {
						System.out.println("tat");
						rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1,
								Float.parseFloat(rs3.getString(3)), sold, sold * Float.parseFloat(rs3.getString(3)));
						System.out.println("add");
						ReportList.add(rsp);
						System.out.println("ZZZZ");
					}

				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("z");
		return ReportList;
	}

	public static String AddNewWorker(WorkerUser WorkerUser) throws SQLException {
		Statement stmt;

		stmt = conn.createStatement();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.users where UserName='" + WorkerUser.getUserName() + "'");
		if (rs.next() == true) {
			return "UserNameAlreadyExists";
		}
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + WorkerUser.getUserID() + "'");
		if (rs1.next() == true) {
			return "IDAlreadyExists";
		}
		String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
				+ " values (?, ?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt = conn.prepareStatement(query);
		preparedStmt.setString(1, WorkerUser.getUserID());
		preparedStmt.setString(2, WorkerUser.getUserName());
		preparedStmt.setString(3, WorkerUser.getPassword());
		preparedStmt.setString(4, "Worker");
		preparedStmt.setInt(5, 0);
		preparedStmt.setInt(6, 1);
		preparedStmt.setString(7, "Active");
		preparedStmt.execute();

		String query1 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, WorkerUser.getUserID());
		preparedStmt1.setString(2, WorkerUser.getFirstName());
		preparedStmt1.setString(3, WorkerUser.getLastName());
		preparedStmt1.setString(4, WorkerUser.getEmail());
		preparedStmt1.setString(5, WorkerUser.getPhoneNumber());
		preparedStmt1.setInt(6, WorkerUser.getIDRestaurant());
		preparedStmt1.execute();
		return "Updated";

	}

	public static void RemoveWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker  WHERE ID = ?");
		st.setString(1, WorkerUser.getUserID());
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st1.setString(1, WorkerUser.getUserID());
		st1.executeUpdate();
	}

	public static void EditWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement ps, rs;

		ps = conn.prepareStatement(
				"UPDATE assignment3.restaurantworker SET FirstName= ?,LastName=?,Email=?,PhoneNumber=?  WHERE ID = ?");
		ps.setString(1, WorkerUser.getFirstName());
		ps.setString(2, WorkerUser.getLastName());
		ps.setString(3, WorkerUser.getEmail());
		ps.setString(4, WorkerUser.getPhoneNumber());
		ps.setString(5, WorkerUser.getUserID());
		ps.executeUpdate();
		rs = conn.prepareStatement("UPDATE assignment3.users SET UserName= ?,Password=? WHERE ID = ?");
		rs.setString(1, WorkerUser.getUserName());
		rs.setString(2, WorkerUser.getPassword());
		rs.setString(3, WorkerUser.getUserID());
		rs.executeUpdate();

	}

	public static String Create_acceptRestaurant(Resturaunt res) throws SQLException {
		PreparedStatement ps;
		try {
			String query1 = " insert into assignment3.restaurant (IDRestaurant,RestaurantName,location)"
					+ " values (?, ?, ?)";
			ps = conn.prepareStatement(query1);
			ps.setInt(1, res.getResturauntID());
			ps.setString(2, res.getResturaunt_Name());
			ps.setString(3, res.getLocation());
			ps.execute();
		} catch (Exception e) {
			return "This Id is Existes";
		}

		return "updated";

	}

	static boolean GetTheRequestNormalAccount() {
		NormalUsersNotAccepted = new ArrayList<Normal>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * FROM assignment3.users where confirm= 0 ");
			Normal request;
			while (RS.next()) {
				String ID = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + ID + "'");
				while (RS1.next()) {
					request = new Normal(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), Integer.parseInt(RS1.getString(6)), Float.parseFloat(RS1.getString(7)));
					NormalUsersNotAccepted.add(request);
				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	public static void InsertNewNormalAccountWithVisa(Visa visa, User user, Normal NorUser) throws SQLException {
		InsertNewNormalAccountWithOutVisa(user, NorUser);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();

	}

	public static String InsertNewNormalAccountWithOutVisa(User user, Normal NorUser) throws SQLException {
		Statement stmt;

		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, NorUser.getID());
			preparedStmt1.setString(2, NorUser.getFirstName());
			preparedStmt1.setString(3, NorUser.getLastName());
			preparedStmt1.setString(4, NorUser.getEmail());
			preparedStmt1.setString(5, NorUser.getPhoneNumber());
			preparedStmt1.setInt(6, NorUser.getVisaIsAvailable());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, String.valueOf(NorUser.getW4C()));
			preparedStmt2.setString(2, user.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	public static boolean updatePassword(User user) {
		System.out.println("user password updated ...." + user.getUserName());
		PreparedStatement ps;
		try {

			ps = conn.prepareStatement("UPDATE assignment3.users SET Password= ? WHERE ID = ?");
			ps.setString(1, user.getPassword());
			ps.setString(2, user.getID());

			if (ps.executeUpdate() == 0) {
				System.out.println("Table Update Error!");
				return false;
			} else {
				System.out.println("update user with ID:" + user.getID() + " password to " + user.getPassword());
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return true;
	}

	public static String InsertNewBussinessAccount(BussinessUser user) throws SQLException {
		Statement stmt;
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getFirstName());
			preparedStmt.setString(3, user.getLastName());
			preparedStmt.setString(4, user.getPhoneNumber());
			preparedStmt.setString(5, user.getEmail());
			preparedStmt.setString(6, user.getCompany());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	private static ArrayList<Addition> getAdditions(int itemId) {
		String sql = "select * from assignment3.item_addition where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		ArrayList<Addition> list = new ArrayList<Addition>();
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				Addition tmp = new Addition(rs.getString("name"));
				list.add(tmp);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return list;
	}

	// get item for specific menu
	private static Item getItems(int itemId) {
		String sql = "select * from assignment3.item where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		Item item = null;
		ArrayList<Addition> list;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				String cat = rs.getString("category");
				Category c = Category.valueOf(cat.toString());
				list = getAdditions(itemId);
				item = new Item(itemId, rs.getString("Item_name"), rs.getDouble("Item_price"), c, list);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return item;
	}

	// get menu for each restaurant, calls getItems function to get items for menu
	private static Menu getMenu(int ResId) {
		Menu m = null;
		Item item = null;
		Statement st = null;
		HashMap<Item, Integer> items2 = new HashMap<>();
		// ArrayList<Item> items = new ArrayList<>();
		ResultSet rs = null;
		String sql = "select * from assignment3.menu where IDRestaurant=" + ResId;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				int itemId = rs.getInt("Item_ID");
				item = getItems(itemId);
				items2.put(item, rs.getInt("quantity"));
				// items.add(item);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		m = new Menu(items2);
		return m;
	}

	// return all restaurants from data base to display to the client
	public static ArrayList<Resturaunt> getAllResturaunts() {
		ArrayList<Resturaunt> resList = new ArrayList<>();
		ResultSet rs = null;
		PreparedStatement ps = null;
		String sql = "select * from assignment3.restaurant";
		try {
			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				int ResId = rs.getInt("IDRestaurant");
				Menu m = getMenu(ResId);
				Resturaunt r = new Resturaunt(ResId, rs.getString("RestaurantName"), m);
				resList.add(r);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return resList;
	}

	public static String companyChecker(String cname11) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.company where confirm='" + 1 + "' and companyname='" + cname11 + "'");
			if (rs.next() == true) {
				return "companyExist";
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static W4CNormal getW4C(User user) {
		Statement stmt;
		W4CNormal w4c = null;
		String sql = null;
		if (user.getUserType().equals("Normal"))
			sql = "select * from assignment3.w4cnormal where IDuser=" + user.getID();
		else if (user.getUserType().equals("Bussiness"))
			sql = "select * from assignment3.w4cbussiness where IDuser=" + user.getID();

		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			while (rs.next()) {
				if (user.getUserType().equals("Normal")) {
					w4c = new W4CNormal(rs.getInt(1), user);
					user.setW4c(w4c);
					System.out.println(user.getW4c().getCode());
				} else if (user.getUserType().equals("Bussiness")) {
					w4c = new W4CBussiness(rs.getInt(1), user, rs.getInt(2));
					user.setW4c(w4c);
				}
			}
		} catch (SQLException e) {

			e.printStackTrace();
		}
		return w4c;
	}

	public static ArrayList<Item> getallmaindish(int id, String type) throws SQLException {
		Item Items = null;
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Itemss = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					String cat = RS1.getString("category");
					Category c = Category.valueOf(cat.toString());
					addition = GetAllAddition(itemid);
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							(ArrayList<Addition>) addition, Integer.parseInt(RS.getString(3)), c);
					Items.setCate(cat);
					Itemss.add(Items);

				}
			}
			return Itemss;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static ArrayList<Addition> GetAllAddition(int itemid) throws SQLException {
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Addition add;
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("select * from assignment3.item_addition where Item_ID='" + itemid + "'");
		while (RS.next()) {
			add = new Addition(RS.getString(2));
			addition.add(add);
			System.out.println(add + "im here");
		}
		return addition;
	}

	public static ArrayList<Item> getallitems(int id) throws SQLException {
		Item Items = null;

		AllItems = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							Integer.parseInt(RS.getString(3)));
					System.out.print(Items);
					AllItems.add(Items);

				}
			}
			return AllItems;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static void generate_qr(String image_name, String qrCodeData) {
		try {
			System.out.println(image_name + " " + qrCodeData);
			String filePath = "D:\\" + image_name + ".png";
			String charset = "UTF-8"; // or "ISO-8859-1"
			Map<EncodeHintType, ErrorCorrectionLevel> hintMap = new HashMap<EncodeHintType, ErrorCorrectionLevel>();
			hintMap.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);
			BitMatrix matrix = new MultiFormatWriter().encode(new String(qrCodeData.getBytes(charset), charset),
					BarcodeFormat.QR_CODE, 200, 200, hintMap);
			MatrixToImageWriter.writeToFile(matrix, filePath.substring(filePath.lastIndexOf('.') + 1),
					new File(filePath));
			System.out.println("QR Code image created successfully!");
		} catch (Exception e) {
			System.err.println(e);
		}
	}

	@Override
	public void initialize(URL location, ResourceBundle resources) {
		// TODO Auto-generated method stub

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 16:25:11.693
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 16:25:11.694
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 16:25:11.727
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package server;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.ResourceBundle;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.MultiFormatWriter;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;
import com.mysql.cj.conf.ConnectionUrl.Type;

import client.ChatClient;
import javafx.fxml.Initializable;
import common.Addition;
import common.BranchManager;
import common.CEOuser;
import common.Category;
import common.Company;
import common.Delivery;
import common.GroupDelivery;
import common.HRUser;
import common.HistogramCEO;
import common.InComeReport;
import common.Item;
import common.ItemAddition;
import common.Menu;
import common.Normal;
import common.Order;
import common.OrdersReport;
import common.PDFList;
import common.PerformenceReport;
import common.RestaurantManager;
import common.RestaurantReport;
import common.Resturaunt;
import common.User;
import common.Visa;
import common.W4CBussiness;
import common.W4CNormal;
import common.BussinessUser;
import common.WorkerUser;

public class mysqlConnection implements Initializable {
	public static User user;
	public static User user1 = null;
	public static ArrayList<String> list;
	public static ArrayList<BussinessUser> requestsList;
	public static ArrayList<User> getlistofnormalaccount;
	public static ArrayList<User> usersfromBiteMeDB;
	public static ArrayList<Item> Itemss;
	public static ArrayList<Item> AllItems;
	public static ArrayList<Company> companys;
	public static ArrayList<Resturaunt> getAllresturaunt;
	public static RestaurantManager restaurantManager;
	public static WorkerUser WorkerUser;
	public static BranchManager branchManager;
	public static HRUser HRManager;
	public static Normal Normaluser;
	public static ArrayList<RestaurantReport> ReportList;
	public static ArrayList<RestaurantReport> ReportListForManager;
	public static Connection conn;
	public static Resturaunt Resturaunt;
	public static ArrayList<Normal> NormalUsersNotAccepted;
	public static BussinessUser BussinessUser;
	public static CEOuser CEOuser1;
	public static ArrayList<User> TakeAllUserThatNotConfiredyet;
	public static ArrayList<User> userfrombitemedata;
	public static ArrayList<Company> CompanyList;
	public static ArrayList<Order> AllOrder;
	public static ArrayList<Item> Allitemsoforders;
	public static ArrayList<ItemAddition> itemsandAddition;
	public static ArrayList<OrdersReport> ordersReport;
	public static ArrayList<InComeReport> incomearr;
	public static ArrayList<PerformenceReport> PerfReport;
	public static ArrayList<HistogramCEO> HistogramArray;
	public static User LoginUser;
	public static int ReportIDCounter = 1;

	@SuppressWarnings("deprecation")
	public static Connection connectToDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}

		try {
			String s1 = "jdbc:mysql://localhost/assignment3?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static Connection connectToBiteMeDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}
//		"jdbc:mysql://localhost/assigment2?serverTimezone=IST", "root","912000bashar"
		try {
			String s1 = "jdbc:mysql://localhost/biteme_data?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed To BiteMe DB");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static void updateW4CforBussiness(BussinessUser user) {
		PreparedStatement ps;

		try {
			ps = conn.prepareStatement("UPDATE assignment3.w4cbussiness SET money= ? WHERE IDuser = ?");
			ps.setDouble(1, user.getW4c().getMoney());
			ps.setString(2, user.getID());
			ps.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static boolean GetGroupNumber(int number) throws SQLException {
		ResultSet rs = null;
		String query = "select * from assignment3.group_delivery where code=" + number;
		Statement st;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(query);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return rs.next();
	}

	public static void InsertGroup(GroupDelivery gp) {
		String sql = "insert into assignment3.group_delivery (code,group_size) values (?,?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(sql);
			preparedStmt.setInt(1, gp.getGroupNum());
			preparedStmt.setInt(2, gp.getGroupSize());
			preparedStmt.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static void soldItems(Order solditems) {
		Statement st;
		ResultSet rs = null;
		String sql;
		int soldupdate = 0;
		int updatesold = 0;
		for (int i = 0; i < solditems.getItems().size(); i++) {
			String query2 = "select quantity from assignment3.menu where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and Item_ID=" + solditems.getItems().get(i).getItem_ID();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query2);
				if (rs.next() == true) {
					updatesold = rs.getInt(1);
					updatesold -= solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.menu SET quantity= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and Item_ID="
							+ solditems.getItems().get(i).getItem_ID();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, updatesold);
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}

			String query = "select Sold from assignment3.solditem where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and ItemID=" + solditems.getItems().get(i).getItem_ID()
					+ " and Month=" + solditems.getMonth() + " and Year=" + solditems.getYear();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query);
				if (rs.next() == true) {
					soldupdate = rs.getInt(1);
					soldupdate += solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.solditem SET Sold= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and ItemID="
							+ solditems.getItems().get(i).getItem_ID() + " and Month=" + solditems.getMonth()
							+ " and Year=" + solditems.getYear();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, soldupdate);
					preparedStmt.execute();

				} else {
					sql = "insert into assignment3.solditem (IDRestaurant,ItemID,Sold,Month,Year) values (?,?,?,?,?)";
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, solditems.getRes().getResturauntID());
					preparedStmt.setInt(2, solditems.getItems().get(i).getItem_ID());
					preparedStmt.setInt(3, solditems.getItems().get(i).getQuantity());
					preparedStmt.setInt(4, solditems.getMonth());
					preparedStmt.setInt(5, solditems.getYear());
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

	}

	public static void newDelivery(Delivery del) {
		String query = " insert into assignment3.delivery (deliveryNum,orderNum,name,phonenumber,address,deliveryType,deliveryDate,clientTxt)"
				+ " values (?, ?, ?, ?, ?, ?,?,?)";

		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, del.getDeliveryNum());
			preparedStmt.setInt(2, del.getOrderNum());
			preparedStmt.setString(3, del.getFirstname());
			preparedStmt.setString(4, del.getPhonenumber());
			preparedStmt.setString(5, del.getAddress());
			preparedStmt.setString(6, del.getDeliveryType());
			preparedStmt.setString(7, del.getDate() + " " + del.getHour() + ":" + del.getMinute());
			preparedStmt.setString(8, del.getClientText());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void newOrder(Order order) {
		String query = " insert into assignment3.order (orderNum,RestaurantID,userID,submitDate,totalPrice,pickupTime)"
				+ " values (?, ?, ?, ?, ?, ?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, order.getOrderNum());
			preparedStmt.setInt(2, order.getRes().getResturauntID());
			preparedStmt.setString(3, order.getUser().getID());
			preparedStmt.setString(4, order.getCurrentDateAndTime());
			preparedStmt.setDouble(5, order.getTotalPrice());
			preparedStmt.setString(6, order.getDate() + " " + order.getHour() + ":" + order.getMinute());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}

		query = "insert into assignment3.order_items (orderNum,item_ID,quantity) values(?,?,?)";
		try {
			for (int i = 0; i < order.getItems().size(); i++) {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, order.getOrderNum());
				preparedStmt.setInt(2, order.getItems().get(i).getItem_ID());
				preparedStmt.setInt(3, order.getItems().get(i).getQuantity());
				preparedStmt.execute();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void order_items_additions(Object itemAddition) {
		ArrayList<Item> item_addition = (ArrayList<Item>) itemAddition;
		String query = "insert into assignment3.order_item_addition (orderNum,item_ID,name) values (?,?,?)";

		for (Item i : item_addition) {
			try {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, i.getOrderNum());
				preparedStmt.setInt(2, i.getItem_ID());
				preparedStmt.setString(3, i.getAdditions_names());
				// preparedStmt.setInt(4, i.getIndex());
				preparedStmt.execute();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}

	public static int getOrderID() {
		Statement st;
		ResultSet rs = null;
		int orderNum = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order");
			if (rs.next()) {
				orderNum = rs.getInt(1);
				if (orderNum == 0)
					return orderNum;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order ORDER BY orderNum DESC LIMIT 1");
			if (rs.next()) {
				orderNum = rs.getInt(1);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return orderNum;
	}

	public static int getIND() {
		Statement st;
		ResultSet rs = null;
		int ind = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order_item_addition");
			if (rs.next()) {
				ind = rs.getInt(1);
				if (ind == 0)
					return ind;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order_item_addition ORDER BY ind DESC LIMIT 1");
			if (rs.next()) {
				ind = rs.getInt(4);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return ind;
	}

	public static void DeleteAllReports() throws SQLException {
		Statement ps = conn.createStatement();
		PreparedStatement st, st1, st2, st3;
		st = conn.prepareStatement("DELETE FROM assignment3.ordersreport");
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.reports");
		st1.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.quarterlypdf");
		st2.executeUpdate();
		st3 = conn.prepareStatement("DELETE FROM assignment3.incomereports");
		st3.executeUpdate();
	}

	public static ArrayList<PDFList> PDFLists() throws SQLException {
		System.out.println("First");
		ArrayList<PDFList> PDFListArray = new ArrayList<>();
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Sent='" + 1 + "'");
		while (rs1.next()) {
			PDFList P = new PDFList(rs1.getString(1), rs1.getInt(2), rs1.getString(3));
			PDFListArray.add(P);
		}
		return PDFListArray;
	}

	public static String SendPDFToCeo(String location, int year, String Months) throws SQLException {
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + Months + "'");
		if (rs1.next()) {
			String query = "update assignment3.quarterlypdf set Sent = ? where Location = ? and Year = ? and Month = ?";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, 1);
			preparedStmt.setString(2, location);
			preparedStmt.setInt(3, year);
			preparedStmt.setString(4, Months);
			preparedStmt.executeUpdate();
			return "Updated";
		}
		if (year > EchoServer.Year)
			return "NotPassed";
		if (year < 2021)
			return "NotOpend";
		return null;
	}

	public static void InsertPDFtoDB(int year, int month, String Location)
			throws SQLException, DocumentException, IOException {
		if (month % 3 != 0) {
			return;
		}
		System.out.println("Inserting Q");
		String StringMonth = null;
		ArrayList<PerformenceReport> PReport = new ArrayList<>();
		ArrayList<RestaurantReport> RReport = new ArrayList<>();
		GetReport(Location, month, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 1, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 2, year, "Performence");
		PReport.addAll(PerfReport);
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.restaurant where Location='" + Location + "'");
		while (rs2.next()) {
			int RestaurantID = rs2.getInt(1);
			RReport.addAll(GetReportForManager(RestaurantID, month - 2, year));
		}
		if (month == 12) {
			StringMonth = "10,11,12";
		}
		if (month == 9) {
			StringMonth = "7,8,9";
		}
		if (month == 6) {
			StringMonth = "4,5,6";
		}
		if (month == 3) {
			StringMonth = "1,2,3";
		}
		String str = Location + String.valueOf(year) + String.valueOf(month);
		Document DocPDF = CreatePDF(PReport, RReport, str);
		String query2 = " insert into assignment3.quarterlypdf (Location,Year,Month,PDF,Sent)"
				+ " values (?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
		preparedStmt2.setString(1, Location);
		preparedStmt2.setInt(2, year);
		preparedStmt2.setString(3, StringMonth);
		InputStream inputStream = new FileInputStream(new File("C:\\G5BiteMe\\Report" + str + ".pdf"));
		preparedStmt2.setBlob(4, inputStream);
		preparedStmt2.setInt(5, 0);
		preparedStmt2.execute();
	}

	public static Document CreatePDF(ArrayList<PerformenceReport> PReport, ArrayList<RestaurantReport> RReport,
			String LYM) throws DocumentException, IOException {
		Document doc = new Document();
		System.out.println("Creating PDF Arrays");
		System.out.println(PReport.toString());
		System.out.println(RReport.toString());
		PdfWriter.getInstance(doc, new FileOutputStream("C:\\G5BiteMe\\Report" + LYM + ".pdf"));
		doc.open();
		PdfPTable tablepdf = new PdfPTable(5);
		tablepdf.addCell("Order ID");
		tablepdf.addCell("Restaurant Name");
		tablepdf.addCell("Order Time");
		tablepdf.addCell("Arrival Time");
		tablepdf.addCell("Condition");
		for (int i = 0; i < PReport.size(); i++) {
			int OrderID = PReport.get(i).getOrderID();
			String StringOrderID = String.valueOf(OrderID);
			String RName = PReport.get(i).getRestaurantName();
			Time OrderTime = PReport.get(i).getOrderTime();
			String OrderTimeString = String.valueOf(OrderTime);
			Time Arrival = PReport.get(i).getArrival();
			String ArrivalString = String.valueOf(Arrival);
			String Condition = PReport.get(i).getCondition();
			tablepdf.addCell(StringOrderID);
			tablepdf.addCell(RName);
			tablepdf.addCell(OrderTimeString);
			tablepdf.addCell(ArrivalString);
			tablepdf.addCell(Condition);
		}
		doc.add(tablepdf);
		doc.newPage();
		PdfPTable tablepdf1 = new PdfPTable(6);
		tablepdf1.addCell("Item ID");
		tablepdf1.addCell("Item Name");
		tablepdf1.addCell("Quantity");
		tablepdf1.addCell("Price per one");
		tablepdf1.addCell("Sold");
		tablepdf1.addCell("InCome");

		for (int i = 0; i < RReport.size(); i++) {
			int ItemID = RReport.get(i).getItemID();
			String StringItemID = String.valueOf(ItemID);
			String ItemName = RReport.get(i).getItemName();
			String Quantity = String.valueOf(RReport.get(i).getQuantity());
			String PerOne = String.valueOf(RReport.get(i).getPrice1());
			String Sold = String.valueOf(RReport.get(i).getSold());
			String InCome = String.valueOf(RReport.get(i).getInCome());

			tablepdf1.addCell(StringItemID);
			tablepdf1.addCell(ItemName);
			tablepdf1.addCell(Quantity);
			tablepdf1.addCell(PerOne);
			tablepdf1.addCell(Sold);
			tablepdf1.addCell(InCome);
		}
		doc.add(tablepdf1);
		doc.close();
		return doc;
	}

	public static String GetHistogram(String area, int year1, String months) throws SQLException {
		HistogramArray = new ArrayList<HistogramCEO>();
		boolean flag = false;
		int month1 = 0;
		int month3 = 0;
		if (months.equals("1,2,3")) {
			month1 = 1;
			month3 = 3;
		}
		if (months.equals("4,5,6")) {
			month1 = 4;
			month3 = 6;
		}
		if (months.equals("7,8,9")) {
			month1 = 7;
			month3 = 9;
		}
		if (months.equals("10,11,12")) {
			month1 = 10;
			month3 = 12;
		}
		if (month3 > EchoServer.Month && year1 == EchoServer.Year) {
			return "NotPassed";
		}
		if (year1 > EchoServer.Year) {
			return "NotPassed";
		}
		if (month3 < 10 && year1 == 2021) {
			return "NotOpend";
		}
		if (year1 < 2021) {
			return "NotOpend";
		}
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
				+ "' and Month>='" + month1 + "' and Month <='" + month3 + "' and Year='" + year1 + "'");
		while (rs2.next()) {
			String type = rs2.getString(1);
			if (type.equals("InCome")) {
				flag = false;
				int ID = rs2.getInt(5);
				String month = rs2.getString(4);
				Statement stmt3;
				stmt3 = conn.createStatement();
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs3.next()) {
					String RestaurantName = rs3.getString(2);
					double InCome = rs3.getDouble(3);
					HistogramCEO ceo = new HistogramCEO(RestaurantName, InCome, 0);
					for (int i = 0; i < HistogramArray.size(); i++) {
						if (HistogramArray.get(i).getRestaurantName().equals(ceo.getRestaurantName())) {
							flag = true;
							double a = HistogramArray.get(i).getInCome();
							HistogramArray.get(i).setInCome(InCome + a);
						}
					}
					if (!flag) {
						HistogramArray.add(ceo);
					}
				}
				Statement stmt4;
				stmt4 = conn.createStatement();
				String ord = "Order";
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
						+ "' and Month='" + month + "' and Year='" + year1 + "' and Type='" + ord + "'");
				if (rs4.next()) {
					int ordID = rs4.getInt(5);
					Statement stmt5;
					stmt5 = conn.createStatement();
					ResultSet rs5 = stmt5
							.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ordID + "'");
					while (rs5.next()) {
						String RN = rs5.getString(2);
						int b = rs5.getInt(4);
						System.out.println("Printing B");
						System.out.println(b);
						for (int i = 0; i < HistogramArray.size(); i++) {
							if (HistogramArray.get(i).getRestaurantName().equals(RN)) {
								int a = HistogramArray.get(i).getSold();
								System.out.println("Printing a");
								System.out.println(a);
								HistogramArray.get(i).setSold(a + b);
								System.out.println("END");
								System.out.println(HistogramArray.get(i).getSold());
							}
						}
					}
				}
			}
		}
		return "Done";

	}

	public static String GetReport(String location, int month, int year, String type) throws SQLException {
		boolean flag = false;
		if (year > EchoServer.Year) {
			return "NotPassed";
		}
		if (month > EchoServer.Month && year == EchoServer.Year) {
			return "NotPassed";
		}
		incomearr = new ArrayList<InComeReport>();
		ordersReport = new ArrayList<OrdersReport>();
		PerfReport = new ArrayList<PerformenceReport>();
		Statement stmt;
		Statement stmt5;
		stmt = conn.createStatement();
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.reports where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + month + "' and Type ='" + type + "'");
		while (rs1.next() == true) {
			flag = true;
			if (type.equals("InCome")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs2.next() == true) {
					InComeReport income = new InComeReport(rs2.getString(2), rs2.getDouble(3));
					incomearr.add(income);
				}
				System.out.println(incomearr.toString());
			}
			if (type.equals("Order")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ID + "'");
				while (rs2.next() == true) {
					OrdersReport orderReport = new OrdersReport(rs2.getString(2), rs2.getString(3), rs2.getInt(4));
					ordersReport.add(orderReport);
				}
				System.out.println(ordersReport.toString());
			}
		}
		if (flag) {
			return "Done";
		}
		if (type.equals("Performence")) {
			stmt5 = conn.createStatement();
			ResultSet rs11 = stmt5
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs11.next()) {
				flag = true;
				String ResName = rs11.getString(2);
				stmt = conn.createStatement();
				ResultSet rs12 = stmt.executeQuery("SELECT * FROM assignment3.performencereports where RestaurantName='"
						+ ResName + "' and Year='" + year + "' and Month ='" + month + "'");
				while (rs12.next()) {
					Time order = rs12.getTime(3);
					Time arrival = rs12.getTime(4);
					int Diff = order.compareTo(arrival);
					if (Diff == 1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Early");
						PerfReport.add(perf);
					}
					if (Diff == 0) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Exactly");
						PerfReport.add(perf);
					}
					if (Diff == -1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Late");
						PerfReport.add(perf);
					}
				}
			}

		}
		System.out.println(PerfReport);
		if (PerfReport.size() == 0 && flag == true) {
			return "NotOpened";
		}
		if (flag) {
			return "Done";
		}
		return "NotOpened";
	}

	static void CreateInComeReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		incomearr = new ArrayList<InComeReport>();
		double income = 0;
		try {
			Statement stmt1 = conn.createStatement();
			Statement stmt2 = conn.createStatement();
			Statement stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				income = 0;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int ItemID = Integer.parseInt(rs2.getString(2));
					int sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						income += sold * rs3.getDouble(3);
					}
				}
				InComeReport ICR = new InComeReport(RestaurantName, income);
				incomearr.add(ICR);
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "InCome");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < incomearr.size(); i++) {
				String query1 = " insert into assignment3.incomereports (ID,RestaurantName,InCome)"
						+ " values (?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, incomearr.get(i).getRestaurantName());
				preparedStmt1.setDouble(3, incomearr.get(i).getIncome());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}

	static void CreateOrdersReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		boolean flag2 = false;
		Statement stmt1;
		Statement stmt2;
		Statement stmt3;
		ordersReport = new ArrayList<OrdersReport>();
		try {
			stmt1 = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int sold = rs2.getInt(3);
					int ItemID = Integer.parseInt(rs2.getString(2));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						String Catalog = rs3.getString(4);
						OrdersReport Order = new OrdersReport(RestaurantName, Catalog, sold);
						for (int i = 0; i < ordersReport.size(); i++) {
							if (ordersReport.get(i).getRestaurantName().equals(Order.getRestaurantName())
									&& ordersReport.get(i).getCatalog().equals(Order.getCatalog())) {
								ordersReport.get(i).setSold(ordersReport.get(i).getSold() + Order.getSold());
								flag2 = true;
							}
						}
						if (!flag2)
							ordersReport.add(Order);
						flag2 = false;
					}
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "Order");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < ordersReport.size(); i++) {
				String query1 = " insert into assignment3.ordersreport (ID,RestaurantName,Catalog,Sold)"
						+ " values (?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, ordersReport.get(i).getRestaurantName());
				preparedStmt1.setString(3, ordersReport.get(i).getCatalog());
				preparedStmt1.setInt(4, ordersReport.get(i).getSold());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}
/////////////////////////////////////////////////////////////////

	public static void insidealldatafromBiteMeDB() throws SQLException {
		userfrombitemedata = new ArrayList<User>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From biteme_data.users");
		User user = null;
		while (RS.next()) {
			try {
				user = new User(RS.getString(1), RS.getString(4), RS.getString(5), RS.getString(8), RS.getString(2),
						RS.getString(6), RS.getString(7), RS.getString(3), RS.getString(14), RS.getString(13), 0,
						Integer.parseInt(RS.getString(11)), RS.getString(12), Integer.parseInt(RS.getString(10)),
						Integer.parseInt(RS.getString(15)));
				userfrombitemedata.add(user);
				String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
						+ " values (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setString(1, user.getID());
				preparedStmt.setString(2, user.getUserName());
				preparedStmt.setString(3, user.getPassword());
				preparedStmt.setString(4, user.getUserType());
				preparedStmt.setInt(5, 0);
				preparedStmt.setInt(6, user.getConfirm());
				preparedStmt.setString(7, user.getStatus());
				preparedStmt.execute();
			} catch (Exception e) {
				System.out.println("importing data ...");
			}
			switch (user.getUserType()) {
			case "BranchManager":
				String query1 = " insert into assignment3.branchmanager (ID,FirstName,LastName,Email,PhoneNumber,location)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setString(1, user.getID());
				preparedStmt1.setString(2, user.getFirstname());
				preparedStmt1.setString(3, user.getLastname());
				preparedStmt1.setString(4, user.getEmail());
				preparedStmt1.setString(5, user.getPhonenumber());
				preparedStmt1.setString(6, user.getLocation());
				preparedStmt1.execute();
				break;
			case "Normal":
				String query2 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
				preparedStmt2.setString(1, user.getID());
				preparedStmt2.setString(2, user.getFirstname());
				preparedStmt2.setString(3, user.getLastname());
				preparedStmt2.setString(4, user.getEmail());
				preparedStmt2.setString(5, user.getPhonenumber());
				preparedStmt2.setInt(6, user.getVisaavailable());
				preparedStmt2.execute();
				break;
			case "Bussiness":
				String query3 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt3 = conn.prepareStatement(query3);
				preparedStmt3.setString(1, user.getID());
				preparedStmt3.setString(2, user.getFirstname());
				preparedStmt3.setString(3, user.getLastname());
				preparedStmt3.setString(4, user.getEmail());
				preparedStmt3.setString(5, user.getPhonenumber());
				preparedStmt3.setString(6, user.getCompany());
				preparedStmt3.execute();
				break;
			case "CEO":
				String query4 = " insert into assignment3.ceouser (ID,FirstName,LastName,Email,PhoneNumber)"
						+ " values (?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
				preparedStmt4.setString(1, user.getID());
				preparedStmt4.setString(2, user.getFirstname());
				preparedStmt4.setString(3, user.getLastname());
				preparedStmt4.setString(4, user.getEmail());
				preparedStmt4.setString(5, user.getPhonenumber());
				preparedStmt4.execute();
				break;
			case "RestaurantManager":
				String query5 = " insert into assignment3.restaurantmanager (ID,FirstName,LastName,Email,PhoneNumber,IDRestaurant)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt5 = conn.prepareStatement(query5);
				preparedStmt5.setString(1, user.getID());
				preparedStmt5.setString(2, user.getFirstname());
				preparedStmt5.setString(3, user.getLastname());
				preparedStmt5.setString(4, user.getEmail());
				preparedStmt5.setString(5, user.getPhonenumber());
				preparedStmt5.setInt(6, user.getIdrestaurant());
				preparedStmt5.execute();
				break;
			case "HR":
				Statement stmt;
				String query6 = " insert into assignment3.hruser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
				preparedStmt6.setString(1, user.getID());
				preparedStmt6.setString(2, user.getFirstname());
				preparedStmt6.setString(3, user.getLastname());
				preparedStmt6.setString(4, user.getEmail());
				preparedStmt6.setString(5, user.getPhonenumber());
				preparedStmt6.setString(6, user.getCompany());
				preparedStmt6.execute();

				break;
			case "Worker":
				String query7 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt7 = conn.prepareStatement(query7);
				preparedStmt7.setString(1, user.getID());
				preparedStmt7.setString(2, user.getFirstname());
				preparedStmt7.setString(3, user.getLastname());
				preparedStmt7.setString(4, user.getEmail());
				preparedStmt7.setString(5, user.getPhonenumber());
				preparedStmt7.setInt(6, user.getIdrestaurant());
				preparedStmt7.execute();

				break;
			}
		}
	}

	public static void deletealldata() throws SQLException {
		Statement ps = conn.createStatement();

		PreparedStatement st, st1, st2 = null, st3 = null;

		ResultSet rs = ps.executeQuery("SELECT * FROM assignment3.users where confirm=0");
		while (rs.next() == true) {
			String ID = rs.getString(1);
			String type = rs.getString(4);

			if (type.equals("Normal")) {
				st = conn.prepareStatement("DELETE FROM assignment3.normaluser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("Bussiness")) {
				st = conn.prepareStatement("DELETE FROM assignment3.bussinessuser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("BranchManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.branchmanager");
				st.executeUpdate();
			} else if (type.equals("CEO")) {
				st = conn.prepareStatement("DELETE FROM assignment3.ceouser");
				st.executeUpdate();
			} else if (type.equals("RestaurantManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantmanager");
				st.executeUpdate();
			} else if (type.equals("HR")) {
				st = conn.prepareStatement("DELETE FROM assignment3.hruser");
				st.executeUpdate();
			} else if (type.equals("Worker")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker");
				st.executeUpdate();
			}
		}
		st = conn.prepareStatement("DELETE FROM assignment3.users WHERE confirm = ?");
		st.setInt(1, 0);
		st.executeUpdate();
	}

	// public WorkerUser(String userID, String firstName, String lastName, String
	// userName, String password, String email,
	// String phoneNumber, int iDRestaurant) {
	public static void LogOutAllAccounts() throws SQLException {
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? ");
		ps.setInt(1, 0);
		ps.executeUpdate();
	}

	public static String AddNewUser(User user, Object msgData1, String table) throws SQLException {
		PreparedStatement st;
		try {
			Statement stmt = conn.createStatement();

			ResultSet rs1 = stmt
					.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			ResultSet rs3 = stmt.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs3.next() == true) {
				return "IDAlreadyExists";
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		if (table.equals("normaluser")) {
			W4CNormal w4c = (W4CNormal) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, user.getID());
			preparedStmt1.setString(2, user.getFirstname());
			preparedStmt1.setString(3, user.getLastname());
			preparedStmt1.setString(4, user.getEmail());
			preparedStmt1.setString(5, user.getPhonenumber());
			preparedStmt1.setInt(6, user.getVisaavailable());
			preparedStmt1.execute();

			String query6 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
			preparedStmt6.setString(1, code);
			preparedStmt6.setString(2, w4c.getUser().getID());
			preparedStmt6.execute();

		} else {
			W4CBussiness w4c = (W4CBussiness) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query2 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, user.getID());
			preparedStmt2.setString(2, user.getFirstname());
			preparedStmt2.setString(3, user.getLastname());
			preparedStmt2.setString(4, user.getEmail());
			preparedStmt2.setString(5, user.getPhonenumber());
			preparedStmt2.setString(6, user.getCompany());
			preparedStmt2.execute();

			String query4 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
			preparedStmt4.setString(1, code);
			preparedStmt4.setDouble(2, w4c.getMoney());
			preparedStmt4.setString(3, w4c.getUser().getID());
			preparedStmt4.execute();

		}
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? , UserType=? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, user.getUserType());
		ps.setString(4, user.getID());
		ps.executeUpdate();

		return "updated";
	}

	public static String AddNewUserwithvisa(User user, Object msgData1, Visa visa, String table) throws SQLException {
		String str = AddNewUser(user, msgData1, table);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.normaluser SET VisaIsAvailable= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, user.getID());
		ps.executeUpdate();

		return str;
	}

	public static void confirmCompane(String cname) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where companyname='" + cname + "'");
		if (rs.next() != true) {
			String query1 = " insert into assignment3.company (companyname,confirm)" + " values (?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, cname);
			preparedStmt1.setInt(2, 0);
			preparedStmt1.execute();
		}
	}

	public static void companyConfirm(String cname) throws SQLException {
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.company SET confirm= ? WHERE companyname = ?");
		ps.setInt(1, 1);
		ps.setString(2, cname);
		ps.executeUpdate();
	}

	public static ArrayList<Company> getCompanyList() {
		Statement stmt;
		CompanyList = new ArrayList<Company>();
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where confirm='" + 0 + "'");
			while (rs.next() == true) {
				Company company = new Company(rs.getString(1), rs.getInt(2));
				CompanyList.add(company);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return CompanyList;
	}

	public static ArrayList<User> TakeAllUserThatNotConfiredyet() throws SQLException {
		TakeAllUserThatNotConfiredyet = new ArrayList<>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From assignment3.users where UserType= 'null'");
		User users;
		while (RS.next()) {
			String id = RS.getString(1);

			for (int i = 0; i < userfrombitemedata.size(); i++) {
				if (id.equals(userfrombitemedata.get(i).getID())) {
					TakeAllUserThatNotConfiredyet.add(userfrombitemedata.get(i));
				}
			}
		}
		return TakeAllUserThatNotConfiredyet;
	}

	public static ArrayList<Company> GetallAvailableCompany() throws SQLException {
		companys = new ArrayList<Company>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.company where confirm=1");
		Company company;
		while (RS.next()) {
			company = new Company(RS.getString(1), Integer.parseInt(RS.getString(2)));
			companys.add(company);
		}
		return companys;

	}

	///////////////
	public static ArrayList<Order> GetAllOrder(int id) throws NumberFormatException, SQLException {
		AllOrder = new ArrayList<Order>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.order where RestaurantID='" + id + "'");
		Order order;
		while (RS.next()) {
			order = new Order(Integer.parseInt(RS.getString(1)), Double.parseDouble(RS.getString(5)), RS.getString(4),
					RS.getString(6), RS.getString(3));
			AllOrder.add(order);
		}
		return AllOrder;
	}

	/////////////////////
	public static void UpdateItem(Item item, String str) throws SQLException {
		PreparedStatement ps, ps1;
		ps1 = conn.prepareStatement("UPDATE assignment3.menu SET quantity= ? WHERE Item_ID = ?");
		ps1.setInt(1, item.getQuantity());
		ps1.setInt(2, item.getItem_ID());
		ps1.executeUpdate();
		ps = conn.prepareStatement("UPDATE assignment3.item SET Item_name= ?, Item_price=? WHERE Item_ID = ?");
		ps.setString(1, item.getItem_Name());
		ps.setDouble(2, item.getPrice());
		ps.setInt(3, item.getItem_ID());
		ps.executeUpdate();

	}

//////////////////
	public static void RemoveItem(Item item) throws SQLException {
		PreparedStatement st, st1;
		st1 = conn.prepareStatement("DELETE FROM assignment3.menu WHERE Item_ID = ?");
		st1.setInt(1, item.getItem_ID());
		st1.executeUpdate();
		st = conn.prepareStatement("DELETE FROM assignment3.item WHERE Item_ID = ?");
		st.setInt(1, item.getItem_ID());
		st.executeUpdate();

	}

	//////////////////
	public static void RemoveItemAddition(Item item, String addition) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.item_addition WHERE name=? and Item_ID = ?");
		st.setString(1, addition);
		st.setInt(2, item.getItem_ID());
		st.executeUpdate();

		st1 = conn.prepareStatement("DELETE FROM assignment3.addition WHERE name = ?");
		st1.setString(1, addition);
		st1.executeUpdate();

	}

	/////////////////
	public static void AddItems(Item item, Addition addition, int resid, String str) throws SQLException {
		if (addition == null) {
			String query = " insert into assignment3.item (item_ID,Item_name,Item_price,category)"
					+ " values (?, ?,?,?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, item.getItem_ID());
			preparedStmt.setString(2, item.getItem_Name());
			preparedStmt.setDouble(3, item.getPrice());
			preparedStmt.setString(4, str);
			preparedStmt.execute();
			String query1 = " insert into assignment3.menu (IDRestaurant,item_ID,quantity)" + " values (?, ?,?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setInt(1, resid);
			preparedStmt1.setInt(2, item.getItem_ID());
			preparedStmt1.setInt(3, item.getQuantity());
			preparedStmt1.execute();
		} else {
			String query = " insert into assignment3.addition (name)" + " values (?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, addition.getName());
			preparedStmt.execute();
			String query2 = " insert into assignment3.item_addition (item_ID,name)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setInt(1, item.getItem_ID());
			preparedStmt2.setString(2, addition.getName());
			preparedStmt2.execute();

		}
	}

	public static ArrayList<WorkerUser> GetAllWorkers(int id) throws Exception// get all worker
	{
		ArrayList<WorkerUser> allworker = new ArrayList<WorkerUser>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		WorkerUser WorkerUser;
		ResultSet RS = ps
				.executeQuery("SELECT * From assignment3.restaurantworker where restaurantWorker='" + id + "'");
		while (RS.next()) {
			String idres = RS.getString(1);
			ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.users where ID='" + idres + "'");
			if (RS1.next()) {
				WorkerUser = new WorkerUser(RS1.getString(1), RS.getString(2), RS.getString(3), RS1.getString(2),
						RS1.getString(3), RS.getString(4), RS.getString(5), id);
				WorkerUser.setRestaurantName(getrestaurantname(id).getResturaunt_Name());
				allworker.add(WorkerUser);

			}
		}
		return allworker;
	}

	public static void UpdateStatusOfUsers(User user1) throws SQLException {
		// System.out.println("user status updated ...." + user1.getUserName());
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET status= ? WHERE ID = ?");
		ps.setString(1, user1.getStatus());
		ps.setString(2, user1.getID());
		ps.executeUpdate();

	}

	public static void BussinessAccountHasBeenAccepted(User user) throws SQLException {/// this method that accepted
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setString(1, "1");
		ps.setString(2, "Active");

		ps.setString(3, user.getID());
		ps.executeUpdate();
	}

	// add new business account
	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser, String str)
			throws SQLException {

		System.out.println("i am getting into login query");
		try {
			Statement stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}

			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, str);
			preparedStmt2.setFloat(2, bussinessUser.getW4C());
			preparedStmt2.setString(3, bussinessUser.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	// add new bussiness account with visa
	static String InsertNewBussinessAccountWithVisa(Visa visa, User user, BussinessUser bussinessUser, String str)
			throws SQLException {
		String value = InsertNewBussinessAccount(user, bussinessUser, str);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		return value;

	}

	static int IDForW4C() {
		Random rand = new Random();
		Statement stmt, stmt1;
		try {
			while (true) {
				int W4C = rand.nextInt((999 - 100) + 1) + 100;
				stmt = conn.createStatement();
				stmt1 = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cnormal where code= '" + W4C + "'");
				if (!rs.next()) {
					ResultSet rs1 = stmt
							.executeQuery("SELECT * FROM assignment3.w4cbussiness where code= '" + W4C + "'");
					if (!rs1.next()) {
						System.out.println(W4C);
						return W4C;
					}
				}
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return 5;
	}

//////////////////////
	public static void RefundCustomer(int number) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		stmt1= conn.createStatement();

		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.order where orderNum='"+number+"'");
		if (rs.next() == true) {
			String userid=rs.getString(3);
			ResultSet rs1= stmt1.executeQuery("SELECT * FROM assignment3.users where ID='"+userid+"'");
			if (rs1.next() == true) {
				String type=rs1.getString(4);
				if(type.equals("Bussiness"))
				{
					Double price=rs.getDouble(5);
					price*0.5
				}
			}
		}
	}

	static String LogInChecker(User username) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where UserName='" + username.getUserName()
				+ "' and Password='" + username.getPassword() + "'");
		if (rs.next() == true) {
			if (rs.getInt(5) == 1)
				return "LoggedIn";

			if (rs.getString(7).equals("Locked")) {
				return "Locked";
			}
			LoginUser = new User(rs.getString(1), username.getUserName(), rs.getString(3), rs.getString(4),
					Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
			return "Entered";
		}
		return "NotExist";
	}

	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser) throws SQLException {
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	static User selectuserfromNormalUserTable(User username) {// check if the password and the user name is correct , if
		// yes then send the
// right message

		Statement stmt;
		int status;
		boolean valid = false;
		String usernameStatus;
		String Status;
		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + username.getID() + "'");
			if (rs.next() == true) {
				Status = rs.getString(10);
				user = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));

				usernameStatus = username.getUserName();
				status = rs.getInt("IsLoggedIn");
			}
			return user;

		} catch (SQLException e) {
			e.printStackTrace();
		}

		return null;

	}

	public static void AcceptNewNormalUser(User username) throws SQLException {
		System.out.println(username.getID());
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, username.getID());
		ps.executeUpdate();
	}

	public static void updateClientStatus(User user, int status) {
		System.out.println("user status updated ...." + user.getUserName());
		PreparedStatement ps, rs;
		try {
			ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? WHERE UserName = ?");
			ps.setInt(1, status);
			ps.setString(2, user.getUserName());

			if (ps.executeUpdate() != 0) {
				System.out.println("update " + user.getUserName() + " status to:" + status);

			} else {
				rs = conn.prepareStatement("UPDATE bitemeuser SET IsLoggedIn= ? WHERE UserName = ?");
				rs.setInt(1, status);
				rs.setString(2, user.getUserName());
				rs.executeUpdate();
			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static void deleteId(String id, String sqltable) throws SQLException {
		PreparedStatement st, st1, st2 = null, st3 = null;
		if (sqltable.equals("normaluser")) {
			st = conn.prepareStatement("DELETE FROM assignment3.normaluser WHERE ID = ?");
			st.setString(1, id);
			st.executeUpdate();
			st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
			st1.setString(1, id);
			st1.executeUpdate();
		}
		if (sqltable.equals("restaurant")) {
			st = conn.prepareStatement("DELETE FROM assignment3.restaurant WHERE IDRestaurant = ?");
			st.setInt(1, Integer.parseInt(id));
			st.executeUpdate();
		} else
			st3 = conn.prepareStatement("DELETE FROM assignment3.bussinessuser WHERE ID = ?");
		st3.setString(1, id);
		st3.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st2.setString(1, id);
		st2.executeUpdate();

	}

	static boolean getTheRequestList(String company) {
		requestsList = new ArrayList<BussinessUser>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps
					.executeQuery("SELECT * From assignment3.users where UserType='Bussiness' and status='Frozen'");
			BussinessUser request;
			while (RS.next()) {
				String id = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery(
						"SELECT * From assignment3.bussinessuser where ID='" + id + "'and Company='" + company + "'");
				if (RS1.next()) {
					request = new BussinessUser(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), 0, RS1.getString(6), 0);
					requestsList.add(request);

				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static boolean getAllUsers() {
		getlistofnormalaccount = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from assignment3.users where UserType= 'Normal' and confirm = 1");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				getlistofnormalaccount.add(request);
				System.out.print(getlistofnormalaccount);
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static void putdatafrombitemeDB() {////////////////////////////////////////////////////////////////////////// WTF
		usersfromBiteMeDB = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void isidedatafrombmtosassignment(ArrayList<User> user) {
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}
			System.out.print(usersfromBiteMeDB);

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void getAllResturaunt(String location) {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant where location='" + location + "'");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static void getAllResturaunt() {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static ArrayList<RestaurantReport> GetReportForManager(int restaurantID, int month, int year)
			throws SQLException {
		ReportListForManager = new ArrayList<RestaurantReport>();
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;
		int month2 = month + 2;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();
			ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='" + restaurantID
					+ "' and Month>='" + month + "' and Month <='" + month2 + "' and Year='" + year + "'");
			System.out.println("dd");
			while (rs2.next() == true) {
				System.out.println("jj");
				ItemID = Integer.parseInt(rs2.getString(2));
				sold = Integer.parseInt(rs2.getString(3));
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
				System.out.println(ItemID);
				System.out.println(restaurantID);
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='" + restaurantID
						+ "' and Item_ID= '" + ItemID + "'");
				if (rs4.next() == true) {
					quantity1 = Integer.parseInt(rs4.getString(3));
					System.out.println(quantity1);
				}
				while (rs3.next() == true) {
					System.out.println("tat");
					System.out.println("Babi");
					rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1, Float.parseFloat(rs3.getString(3)),
							sold, sold * Float.parseFloat(rs3.getString(3)));
					System.out.println("add");
					ReportListForManager.add(rsp);
					System.out.println("ZZZZ");
				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println(ReportListForManager);

		return ReportListForManager;
	}

	public static W4CBussiness getW4CBussiness(User user) {
		W4CBussiness w4c = null;
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cbussiness where IDuser=" + user.getID());
			if (rs.next()) {
				w4c = new W4CBussiness(rs.getInt(1), user, rs.getDouble(2));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return w4c;
	}

	static RestaurantManager GetRestaurantManager(User user) {
		Statement stmt, stmt1;
		int status;
		try {
			stmt1 = conn.createStatement();
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");

				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.restaurant where IDRestaurant='"
						+ Integer.parseInt(rs.getString(6)) + "'");
				if (rs1.next() == true) {
					restaurantManager = new RestaurantManager(rs.getString(1), rs.getString(2), rs.getString(3),
							rs.getString(4), rs.getString(5), Integer.parseInt(rs.getString(6)));
					System.out.println(restaurantManager);

					return restaurantManager;
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static void deleteOrder(int orderid) {
		Statement stmt;
		try {
			String SQL = "delete from assignment3.order where orderNum=?";
			PreparedStatement pstmt = null;

			// get a connection and then in your try catch for executing your delete...

			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_items where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_item_addition where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static boolean CheckDelivery(int orderid) {
		String sql = "select COUNT(*) from assignment3.delivery where orderNum=" + orderid;
		Statement st = null;
		try {
			st = conn.createStatement();
			ResultSet rs = st.executeQuery(sql);
			if (rs.next() == true) {
				String SQL = "delete from assignment3.delivery where orderNum=?";
				PreparedStatement pstmt = null;
				pstmt = conn.prepareStatement(SQL);
				pstmt.setInt(1, orderid);
				pstmt.executeUpdate();
				return true;
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	public static String GetDeliveryDate(int orderid) {
		Statement stmt;
		String date = "";
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("select * from assignment3.delivery where orderNum=" + orderid);
			date = rs.getString(6);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return date;
	}

	static WorkerUser GetRestaurantWorker(User user) {///////////////////////////////////////////
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantworker where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");
				WorkerUser = new WorkerUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return WorkerUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	private static String getitemname(int itemid) throws SQLException {
		Statement stmt, stmt1;
		stmt1 = conn.createStatement();
		String str = null;
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + itemid + "'");
		if (rs1.next() == true) {
			str = rs1.getString(2);

		}
		return str;
	}

/////////////////////////////////////
	public static ArrayList<ItemAddition> GetallOrederItems(int ordernum) throws SQLException {
		Statement stmt, stmt1;

		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ArrayList<ItemAddition> itemsandAddition1 = new ArrayList<>();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.order_item_addition where orderNum='" + ordernum + "'");
		while (rs.next()) {
			int itemid = rs.getInt(2);
			String str = rs.getString(3);
			ItemAddition a = (new ItemAddition(getitemname(itemid), str));
			itemsandAddition1.add(a);
		}
		System.out.print("****&****");
		System.out.print(itemsandAddition1);
		return itemsandAddition1;
	}

	public static String getuser(String id) throws SQLException {
		Statement stmt, stmt1;
		int status;
		String mail = null;
		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + id + "'");
		if (rs.next() == true) {
			String type = rs.getString(4);
			switch (type) {
			case "Normal":
				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + id + "'");
				if (rs1.next() == true) {
					mail = rs1.getString(4);
					return mail;
				}
				break;
			case "Bussiness":
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + id + "'");
				if (rs2.next() == true) {
					mail = rs2.getString(4);
					return mail;
				}
				break;

			}
		}
		return mail;
	}

	static BranchManager GetBranchManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.branchmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				branchManager = new BranchManager(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6));
				return branchManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static CEOuser CeoUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.ceouser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				CEOuser1 = new CEOuser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5));
				return CEOuser1;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static BussinessUser GetBissnessUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				W4CBussiness w4c = getW4CBussiness(user);
				BussinessUser = new BussinessUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6), w4c);
				return BussinessUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding BissessUser!!!");
		return null;
	}

	static Resturaunt getrestaurantname(int id) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT *  FROM assignment3.restaurant where IDRestaurant= " + id);
		if (rs.next() == true) {
			Resturaunt = new Resturaunt(Integer.parseInt(rs.getString(1)), rs.getString(2), rs.getString(3));
			return Resturaunt;
		}
		return null;

	}

	static HRUser GetHRManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.hruser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				HRManager = new HRUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(6));
				return HRManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static Normal getNormalUser(User user) throws SQLException {
		Normal nuser = null;

		Statement st;
		ResultSet rs = null;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("Select * from assignment3.normaluser where ID=" + user.getID());
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		if (rs.next()) {
			try {
				nuser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5));
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return nuser;

	}

	public static Normal Getnormaluser(User user) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				Normaluser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return Normaluser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;
	}

	public static ArrayList<RestaurantReport> GetReportForRestaurant(RestaurantManager restaurantManager, int month,
			int year) throws SQLException {
		ReportList = new ArrayList<RestaurantReport>();
		Statement stmt;
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;

		int IDRestaurant;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();

			System.out.println("aa");
			System.out.println(restaurantManager.getUserName());

			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.restaurantmanager where ID='" + restaurantManager.getUserID() + "'");
			System.out.println("bb");
			if (rs.next() == true) {
				System.out.println("cc");
				IDRestaurant = Integer.parseInt(rs.getString(6));
				System.out.println(IDRestaurant);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				System.out.println("dd");
				while (rs2.next() == true) {
					System.out.println("jj");
					ItemID = Integer.parseInt(rs2.getString(2));
					sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='"
							+ IDRestaurant + "' and Item_ID= '" + ItemID + "'");
					if (rs4.next() == true) {
						quantity1 = Integer.parseInt(rs4.getString(3));
						System.out.println(quantity1);
					}
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					System.out.println("mm");
					while (rs3.next() == true) {
						System.out.println("tat");
						rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1,
								Float.parseFloat(rs3.getString(3)), sold, sold * Float.parseFloat(rs3.getString(3)));
						System.out.println("add");
						ReportList.add(rsp);
						System.out.println("ZZZZ");
					}

				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("z");
		return ReportList;
	}

	public static String AddNewWorker(WorkerUser WorkerUser) throws SQLException {
		Statement stmt;

		stmt = conn.createStatement();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.users where UserName='" + WorkerUser.getUserName() + "'");
		if (rs.next() == true) {
			return "UserNameAlreadyExists";
		}
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + WorkerUser.getUserID() + "'");
		if (rs1.next() == true) {
			return "IDAlreadyExists";
		}
		String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
				+ " values (?, ?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt = conn.prepareStatement(query);
		preparedStmt.setString(1, WorkerUser.getUserID());
		preparedStmt.setString(2, WorkerUser.getUserName());
		preparedStmt.setString(3, WorkerUser.getPassword());
		preparedStmt.setString(4, "Worker");
		preparedStmt.setInt(5, 0);
		preparedStmt.setInt(6, 1);
		preparedStmt.setString(7, "Active");
		preparedStmt.execute();

		String query1 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, WorkerUser.getUserID());
		preparedStmt1.setString(2, WorkerUser.getFirstName());
		preparedStmt1.setString(3, WorkerUser.getLastName());
		preparedStmt1.setString(4, WorkerUser.getEmail());
		preparedStmt1.setString(5, WorkerUser.getPhoneNumber());
		preparedStmt1.setInt(6, WorkerUser.getIDRestaurant());
		preparedStmt1.execute();
		return "Updated";

	}

	public static void RemoveWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker  WHERE ID = ?");
		st.setString(1, WorkerUser.getUserID());
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st1.setString(1, WorkerUser.getUserID());
		st1.executeUpdate();
	}

	public static void EditWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement ps, rs;

		ps = conn.prepareStatement(
				"UPDATE assignment3.restaurantworker SET FirstName= ?,LastName=?,Email=?,PhoneNumber=?  WHERE ID = ?");
		ps.setString(1, WorkerUser.getFirstName());
		ps.setString(2, WorkerUser.getLastName());
		ps.setString(3, WorkerUser.getEmail());
		ps.setString(4, WorkerUser.getPhoneNumber());
		ps.setString(5, WorkerUser.getUserID());
		ps.executeUpdate();
		rs = conn.prepareStatement("UPDATE assignment3.users SET UserName= ?,Password=? WHERE ID = ?");
		rs.setString(1, WorkerUser.getUserName());
		rs.setString(2, WorkerUser.getPassword());
		rs.setString(3, WorkerUser.getUserID());
		rs.executeUpdate();

	}

	public static String Create_acceptRestaurant(Resturaunt res) throws SQLException {
		PreparedStatement ps;
		try {
			String query1 = " insert into assignment3.restaurant (IDRestaurant,RestaurantName,location)"
					+ " values (?, ?, ?)";
			ps = conn.prepareStatement(query1);
			ps.setInt(1, res.getResturauntID());
			ps.setString(2, res.getResturaunt_Name());
			ps.setString(3, res.getLocation());
			ps.execute();
		} catch (Exception e) {
			return "This Id is Existes";
		}

		return "updated";

	}

	static boolean GetTheRequestNormalAccount() {
		NormalUsersNotAccepted = new ArrayList<Normal>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * FROM assignment3.users where confirm= 0 ");
			Normal request;
			while (RS.next()) {
				String ID = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + ID + "'");
				while (RS1.next()) {
					request = new Normal(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), Integer.parseInt(RS1.getString(6)), Float.parseFloat(RS1.getString(7)));
					NormalUsersNotAccepted.add(request);
				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	public static void InsertNewNormalAccountWithVisa(Visa visa, User user, Normal NorUser) throws SQLException {
		InsertNewNormalAccountWithOutVisa(user, NorUser);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();

	}

	public static String InsertNewNormalAccountWithOutVisa(User user, Normal NorUser) throws SQLException {
		Statement stmt;

		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, NorUser.getID());
			preparedStmt1.setString(2, NorUser.getFirstName());
			preparedStmt1.setString(3, NorUser.getLastName());
			preparedStmt1.setString(4, NorUser.getEmail());
			preparedStmt1.setString(5, NorUser.getPhoneNumber());
			preparedStmt1.setInt(6, NorUser.getVisaIsAvailable());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, String.valueOf(NorUser.getW4C()));
			preparedStmt2.setString(2, user.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	public static boolean updatePassword(User user) {
		System.out.println("user password updated ...." + user.getUserName());
		PreparedStatement ps;
		try {

			ps = conn.prepareStatement("UPDATE assignment3.users SET Password= ? WHERE ID = ?");
			ps.setString(1, user.getPassword());
			ps.setString(2, user.getID());

			if (ps.executeUpdate() == 0) {
				System.out.println("Table Update Error!");
				return false;
			} else {
				System.out.println("update user with ID:" + user.getID() + " password to " + user.getPassword());
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return true;
	}

	public static String InsertNewBussinessAccount(BussinessUser user) throws SQLException {
		Statement stmt;
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getFirstName());
			preparedStmt.setString(3, user.getLastName());
			preparedStmt.setString(4, user.getPhoneNumber());
			preparedStmt.setString(5, user.getEmail());
			preparedStmt.setString(6, user.getCompany());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	private static ArrayList<Addition> getAdditions(int itemId) {
		String sql = "select * from assignment3.item_addition where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		ArrayList<Addition> list = new ArrayList<Addition>();
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				Addition tmp = new Addition(rs.getString("name"));
				list.add(tmp);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return list;
	}

	// get item for specific menu
	private static Item getItems(int itemId) {
		String sql = "select * from assignment3.item where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		Item item = null;
		ArrayList<Addition> list;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				String cat = rs.getString("category");
				Category c = Category.valueOf(cat.toString());
				list = getAdditions(itemId);
				item = new Item(itemId, rs.getString("Item_name"), rs.getDouble("Item_price"), c, list);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return item;
	}

	// get menu for each restaurant, calls getItems function to get items for menu
	private static Menu getMenu(int ResId) {
		Menu m = null;
		Item item = null;
		Statement st = null;
		HashMap<Item, Integer> items2 = new HashMap<>();
		// ArrayList<Item> items = new ArrayList<>();
		ResultSet rs = null;
		String sql = "select * from assignment3.menu where IDRestaurant=" + ResId;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				int itemId = rs.getInt("Item_ID");
				item = getItems(itemId);
				items2.put(item, rs.getInt("quantity"));
				// items.add(item);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		m = new Menu(items2);
		return m;
	}

	// return all restaurants from data base to display to the client
	public static ArrayList<Resturaunt> getAllResturaunts() {
		ArrayList<Resturaunt> resList = new ArrayList<>();
		ResultSet rs = null;
		PreparedStatement ps = null;
		String sql = "select * from assignment3.restaurant";
		try {
			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				int ResId = rs.getInt("IDRestaurant");
				Menu m = getMenu(ResId);
				Resturaunt r = new Resturaunt(ResId, rs.getString("RestaurantName"), m);
				resList.add(r);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return resList;
	}

	public static String companyChecker(String cname11) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.company where confirm='" + 1 + "' and companyname='" + cname11 + "'");
			if (rs.next() == true) {
				return "companyExist";
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static W4CNormal getW4C(User user) {
		Statement stmt;
		W4CNormal w4c = null;
		String sql = null;
		if (user.getUserType().equals("Normal"))
			sql = "select * from assignment3.w4cnormal where IDuser=" + user.getID();
		else if (user.getUserType().equals("Bussiness"))
			sql = "select * from assignment3.w4cbussiness where IDuser=" + user.getID();

		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			while (rs.next()) {
				if (user.getUserType().equals("Normal")) {
					w4c = new W4CNormal(rs.getInt(1), user);
					user.setW4c(w4c);
					System.out.println(user.getW4c().getCode());
				} else if (user.getUserType().equals("Bussiness")) {
					w4c = new W4CBussiness(rs.getInt(1), user, rs.getInt(2));
					user.setW4c(w4c);
				}
			}
		} catch (SQLException e) {

			e.printStackTrace();
		}
		return w4c;
	}

	public static ArrayList<Item> getallmaindish(int id, String type) throws SQLException {
		Item Items = null;
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Itemss = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					String cat = RS1.getString("category");
					Category c = Category.valueOf(cat.toString());
					addition = GetAllAddition(itemid);
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							(ArrayList<Addition>) addition, Integer.parseInt(RS.getString(3)), c);
					Items.setCate(cat);
					Itemss.add(Items);

				}
			}
			return Itemss;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static ArrayList<Addition> GetAllAddition(int itemid) throws SQLException {
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Addition add;
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("select * from assignment3.item_addition where Item_ID='" + itemid + "'");
		while (RS.next()) {
			add = new Addition(RS.getString(2));
			addition.add(add);
			System.out.println(add + "im here");
		}
		return addition;
	}

	public static ArrayList<Item> getallitems(int id) throws SQLException {
		Item Items = null;

		AllItems = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							Integer.parseInt(RS.getString(3)));
					System.out.print(Items);
					AllItems.add(Items);

				}
			}
			return AllItems;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static void generate_qr(String image_name, String qrCodeData) {
		try {
			System.out.println(image_name + " " + qrCodeData);
			String filePath = "D:\\" + image_name + ".png";
			String charset = "UTF-8"; // or "ISO-8859-1"
			Map<EncodeHintType, ErrorCorrectionLevel> hintMap = new HashMap<EncodeHintType, ErrorCorrectionLevel>();
			hintMap.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);
			BitMatrix matrix = new MultiFormatWriter().encode(new String(qrCodeData.getBytes(charset), charset),
					BarcodeFormat.QR_CODE, 200, 200, hintMap);
			MatrixToImageWriter.writeToFile(matrix, filePath.substring(filePath.lastIndexOf('.') + 1),
					new File(filePath));
			System.out.println("QR Code image created successfully!");
		} catch (Exception e) {
			System.err.println(e);
		}
	}

	@Override
	public void initialize(URL location, ResourceBundle resources) {
		// TODO Auto-generated method stub

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-28 16:25:11.728
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-28 16:25:11.729
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 16:25:12.293
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package server;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.ResourceBundle;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.MultiFormatWriter;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;
import com.mysql.cj.conf.ConnectionUrl.Type;

import client.ChatClient;
import javafx.fxml.Initializable;
import common.Addition;
import common.BranchManager;
import common.CEOuser;
import common.Category;
import common.Company;
import common.Delivery;
import common.GroupDelivery;
import common.HRUser;
import common.HistogramCEO;
import common.InComeReport;
import common.Item;
import common.ItemAddition;
import common.Menu;
import common.Normal;
import common.Order;
import common.OrdersReport;
import common.PDFList;
import common.PerformenceReport;
import common.RestaurantManager;
import common.RestaurantReport;
import common.Resturaunt;
import common.User;
import common.Visa;
import common.W4CBussiness;
import common.W4CNormal;
import common.BussinessUser;
import common.WorkerUser;

public class mysqlConnection implements Initializable {
	public static User user;
	public static User user1 = null;
	public static ArrayList<String> list;
	public static ArrayList<BussinessUser> requestsList;
	public static ArrayList<User> getlistofnormalaccount;
	public static ArrayList<User> usersfromBiteMeDB;
	public static ArrayList<Item> Itemss;
	public static ArrayList<Item> AllItems;
	public static ArrayList<Company> companys;
	public static ArrayList<Resturaunt> getAllresturaunt;
	public static RestaurantManager restaurantManager;
	public static WorkerUser WorkerUser;
	public static BranchManager branchManager;
	public static HRUser HRManager;
	public static Normal Normaluser;
	public static ArrayList<RestaurantReport> ReportList;
	public static ArrayList<RestaurantReport> ReportListForManager;
	public static Connection conn;
	public static Resturaunt Resturaunt;
	public static ArrayList<Normal> NormalUsersNotAccepted;
	public static BussinessUser BussinessUser;
	public static CEOuser CEOuser1;
	public static ArrayList<User> TakeAllUserThatNotConfiredyet;
	public static ArrayList<User> userfrombitemedata;
	public static ArrayList<Company> CompanyList;
	public static ArrayList<Order> AllOrder;
	public static ArrayList<Item> Allitemsoforders;
	public static ArrayList<ItemAddition> itemsandAddition;
	public static ArrayList<OrdersReport> ordersReport;
	public static ArrayList<InComeReport> incomearr;
	public static ArrayList<PerformenceReport> PerfReport;
	public static ArrayList<HistogramCEO> HistogramArray;
	public static User LoginUser;
	public static int ReportIDCounter = 1;

	@SuppressWarnings("deprecation")
	public static Connection connectToDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}

		try {
			String s1 = "jdbc:mysql://localhost/assignment3?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static Connection connectToBiteMeDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}
//		"jdbc:mysql://localhost/assigment2?serverTimezone=IST", "root","912000bashar"
		try {
			String s1 = "jdbc:mysql://localhost/biteme_data?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed To BiteMe DB");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static void updateW4CforBussiness(BussinessUser user) {
		PreparedStatement ps;

		try {
			ps = conn.prepareStatement("UPDATE assignment3.w4cbussiness SET money= ? WHERE IDuser = ?");
			ps.setDouble(1, user.getW4c().getMoney());
			ps.setString(2, user.getID());
			ps.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static boolean GetGroupNumber(int number) throws SQLException {
		ResultSet rs = null;
		String query = "select * from assignment3.group_delivery where code=" + number;
		Statement st;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(query);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return rs.next();
	}

	public static void InsertGroup(GroupDelivery gp) {
		String sql = "insert into assignment3.group_delivery (code,group_size) values (?,?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(sql);
			preparedStmt.setInt(1, gp.getGroupNum());
			preparedStmt.setInt(2, gp.getGroupSize());
			preparedStmt.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static void soldItems(Order solditems) {
		Statement st;
		ResultSet rs = null;
		String sql;
		int soldupdate = 0;
		int updatesold = 0;
		for (int i = 0; i < solditems.getItems().size(); i++) {
			String query2 = "select quantity from assignment3.menu where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and Item_ID=" + solditems.getItems().get(i).getItem_ID();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query2);
				if (rs.next() == true) {
					updatesold = rs.getInt(1);
					updatesold -= solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.menu SET quantity= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and Item_ID="
							+ solditems.getItems().get(i).getItem_ID();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, updatesold);
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}

			String query = "select Sold from assignment3.solditem where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and ItemID=" + solditems.getItems().get(i).getItem_ID()
					+ " and Month=" + solditems.getMonth() + " and Year=" + solditems.getYear();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query);
				if (rs.next() == true) {
					soldupdate = rs.getInt(1);
					soldupdate += solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.solditem SET Sold= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and ItemID="
							+ solditems.getItems().get(i).getItem_ID() + " and Month=" + solditems.getMonth()
							+ " and Year=" + solditems.getYear();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, soldupdate);
					preparedStmt.execute();

				} else {
					sql = "insert into assignment3.solditem (IDRestaurant,ItemID,Sold,Month,Year) values (?,?,?,?,?)";
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, solditems.getRes().getResturauntID());
					preparedStmt.setInt(2, solditems.getItems().get(i).getItem_ID());
					preparedStmt.setInt(3, solditems.getItems().get(i).getQuantity());
					preparedStmt.setInt(4, solditems.getMonth());
					preparedStmt.setInt(5, solditems.getYear());
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

	}

	public static void newDelivery(Delivery del) {
		String query = " insert into assignment3.delivery (deliveryNum,orderNum,name,phonenumber,address,deliveryType,deliveryDate,clientTxt)"
				+ " values (?, ?, ?, ?, ?, ?,?,?)";

		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, del.getDeliveryNum());
			preparedStmt.setInt(2, del.getOrderNum());
			preparedStmt.setString(3, del.getFirstname());
			preparedStmt.setString(4, del.getPhonenumber());
			preparedStmt.setString(5, del.getAddress());
			preparedStmt.setString(6, del.getDeliveryType());
			preparedStmt.setString(7, del.getDate() + " " + del.getHour() + ":" + del.getMinute());
			preparedStmt.setString(8, del.getClientText());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void newOrder(Order order) {
		String query = " insert into assignment3.order (orderNum,RestaurantID,userID,submitDate,totalPrice,pickupTime)"
				+ " values (?, ?, ?, ?, ?, ?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, order.getOrderNum());
			preparedStmt.setInt(2, order.getRes().getResturauntID());
			preparedStmt.setString(3, order.getUser().getID());
			preparedStmt.setString(4, order.getCurrentDateAndTime());
			preparedStmt.setDouble(5, order.getTotalPrice());
			preparedStmt.setString(6, order.getDate() + " " + order.getHour() + ":" + order.getMinute());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}

		query = "insert into assignment3.order_items (orderNum,item_ID,quantity) values(?,?,?)";
		try {
			for (int i = 0; i < order.getItems().size(); i++) {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, order.getOrderNum());
				preparedStmt.setInt(2, order.getItems().get(i).getItem_ID());
				preparedStmt.setInt(3, order.getItems().get(i).getQuantity());
				preparedStmt.execute();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void order_items_additions(Object itemAddition) {
		ArrayList<Item> item_addition = (ArrayList<Item>) itemAddition;
		String query = "insert into assignment3.order_item_addition (orderNum,item_ID,name) values (?,?,?)";

		for (Item i : item_addition) {
			try {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, i.getOrderNum());
				preparedStmt.setInt(2, i.getItem_ID());
				preparedStmt.setString(3, i.getAdditions_names());
				// preparedStmt.setInt(4, i.getIndex());
				preparedStmt.execute();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}

	public static int getOrderID() {
		Statement st;
		ResultSet rs = null;
		int orderNum = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order");
			if (rs.next()) {
				orderNum = rs.getInt(1);
				if (orderNum == 0)
					return orderNum;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order ORDER BY orderNum DESC LIMIT 1");
			if (rs.next()) {
				orderNum = rs.getInt(1);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return orderNum;
	}

	public static int getIND() {
		Statement st;
		ResultSet rs = null;
		int ind = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order_item_addition");
			if (rs.next()) {
				ind = rs.getInt(1);
				if (ind == 0)
					return ind;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order_item_addition ORDER BY ind DESC LIMIT 1");
			if (rs.next()) {
				ind = rs.getInt(4);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return ind;
	}

	public static void DeleteAllReports() throws SQLException {
		Statement ps = conn.createStatement();
		PreparedStatement st, st1, st2, st3;
		st = conn.prepareStatement("DELETE FROM assignment3.ordersreport");
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.reports");
		st1.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.quarterlypdf");
		st2.executeUpdate();
		st3 = conn.prepareStatement("DELETE FROM assignment3.incomereports");
		st3.executeUpdate();
	}

	public static ArrayList<PDFList> PDFLists() throws SQLException {
		System.out.println("First");
		ArrayList<PDFList> PDFListArray = new ArrayList<>();
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Sent='" + 1 + "'");
		while (rs1.next()) {
			PDFList P = new PDFList(rs1.getString(1), rs1.getInt(2), rs1.getString(3));
			PDFListArray.add(P);
		}
		return PDFListArray;
	}

	public static String SendPDFToCeo(String location, int year, String Months) throws SQLException {
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + Months + "'");
		if (rs1.next()) {
			String query = "update assignment3.quarterlypdf set Sent = ? where Location = ? and Year = ? and Month = ?";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, 1);
			preparedStmt.setString(2, location);
			preparedStmt.setInt(3, year);
			preparedStmt.setString(4, Months);
			preparedStmt.executeUpdate();
			return "Updated";
		}
		if (year > EchoServer.Year)
			return "NotPassed";
		if (year < 2021)
			return "NotOpend";
		return null;
	}

	public static void InsertPDFtoDB(int year, int month, String Location)
			throws SQLException, DocumentException, IOException {
		if (month % 3 != 0) {
			return;
		}
		System.out.println("Inserting Q");
		String StringMonth = null;
		ArrayList<PerformenceReport> PReport = new ArrayList<>();
		ArrayList<RestaurantReport> RReport = new ArrayList<>();
		GetReport(Location, month, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 1, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 2, year, "Performence");
		PReport.addAll(PerfReport);
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.restaurant where Location='" + Location + "'");
		while (rs2.next()) {
			int RestaurantID = rs2.getInt(1);
			RReport.addAll(GetReportForManager(RestaurantID, month - 2, year));
		}
		if (month == 12) {
			StringMonth = "10,11,12";
		}
		if (month == 9) {
			StringMonth = "7,8,9";
		}
		if (month == 6) {
			StringMonth = "4,5,6";
		}
		if (month == 3) {
			StringMonth = "1,2,3";
		}
		String str = Location + String.valueOf(year) + String.valueOf(month);
		Document DocPDF = CreatePDF(PReport, RReport, str);
		String query2 = " insert into assignment3.quarterlypdf (Location,Year,Month,PDF,Sent)"
				+ " values (?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
		preparedStmt2.setString(1, Location);
		preparedStmt2.setInt(2, year);
		preparedStmt2.setString(3, StringMonth);
		InputStream inputStream = new FileInputStream(new File("C:\\G5BiteMe\\Report" + str + ".pdf"));
		preparedStmt2.setBlob(4, inputStream);
		preparedStmt2.setInt(5, 0);
		preparedStmt2.execute();
	}

	public static Document CreatePDF(ArrayList<PerformenceReport> PReport, ArrayList<RestaurantReport> RReport,
			String LYM) throws DocumentException, IOException {
		Document doc = new Document();
		System.out.println("Creating PDF Arrays");
		System.out.println(PReport.toString());
		System.out.println(RReport.toString());
		PdfWriter.getInstance(doc, new FileOutputStream("C:\\G5BiteMe\\Report" + LYM + ".pdf"));
		doc.open();
		PdfPTable tablepdf = new PdfPTable(5);
		tablepdf.addCell("Order ID");
		tablepdf.addCell("Restaurant Name");
		tablepdf.addCell("Order Time");
		tablepdf.addCell("Arrival Time");
		tablepdf.addCell("Condition");
		for (int i = 0; i < PReport.size(); i++) {
			int OrderID = PReport.get(i).getOrderID();
			String StringOrderID = String.valueOf(OrderID);
			String RName = PReport.get(i).getRestaurantName();
			Time OrderTime = PReport.get(i).getOrderTime();
			String OrderTimeString = String.valueOf(OrderTime);
			Time Arrival = PReport.get(i).getArrival();
			String ArrivalString = String.valueOf(Arrival);
			String Condition = PReport.get(i).getCondition();
			tablepdf.addCell(StringOrderID);
			tablepdf.addCell(RName);
			tablepdf.addCell(OrderTimeString);
			tablepdf.addCell(ArrivalString);
			tablepdf.addCell(Condition);
		}
		doc.add(tablepdf);
		doc.newPage();
		PdfPTable tablepdf1 = new PdfPTable(6);
		tablepdf1.addCell("Item ID");
		tablepdf1.addCell("Item Name");
		tablepdf1.addCell("Quantity");
		tablepdf1.addCell("Price per one");
		tablepdf1.addCell("Sold");
		tablepdf1.addCell("InCome");

		for (int i = 0; i < RReport.size(); i++) {
			int ItemID = RReport.get(i).getItemID();
			String StringItemID = String.valueOf(ItemID);
			String ItemName = RReport.get(i).getItemName();
			String Quantity = String.valueOf(RReport.get(i).getQuantity());
			String PerOne = String.valueOf(RReport.get(i).getPrice1());
			String Sold = String.valueOf(RReport.get(i).getSold());
			String InCome = String.valueOf(RReport.get(i).getInCome());

			tablepdf1.addCell(StringItemID);
			tablepdf1.addCell(ItemName);
			tablepdf1.addCell(Quantity);
			tablepdf1.addCell(PerOne);
			tablepdf1.addCell(Sold);
			tablepdf1.addCell(InCome);
		}
		doc.add(tablepdf1);
		doc.close();
		return doc;
	}

	public static String GetHistogram(String area, int year1, String months) throws SQLException {
		HistogramArray = new ArrayList<HistogramCEO>();
		boolean flag = false;
		int month1 = 0;
		int month3 = 0;
		if (months.equals("1,2,3")) {
			month1 = 1;
			month3 = 3;
		}
		if (months.equals("4,5,6")) {
			month1 = 4;
			month3 = 6;
		}
		if (months.equals("7,8,9")) {
			month1 = 7;
			month3 = 9;
		}
		if (months.equals("10,11,12")) {
			month1 = 10;
			month3 = 12;
		}
		if (month3 > EchoServer.Month && year1 == EchoServer.Year) {
			return "NotPassed";
		}
		if (year1 > EchoServer.Year) {
			return "NotPassed";
		}
		if (month3 < 10 && year1 == 2021) {
			return "NotOpend";
		}
		if (year1 < 2021) {
			return "NotOpend";
		}
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
				+ "' and Month>='" + month1 + "' and Month <='" + month3 + "' and Year='" + year1 + "'");
		while (rs2.next()) {
			String type = rs2.getString(1);
			if (type.equals("InCome")) {
				flag = false;
				int ID = rs2.getInt(5);
				String month = rs2.getString(4);
				Statement stmt3;
				stmt3 = conn.createStatement();
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs3.next()) {
					String RestaurantName = rs3.getString(2);
					double InCome = rs3.getDouble(3);
					HistogramCEO ceo = new HistogramCEO(RestaurantName, InCome, 0);
					for (int i = 0; i < HistogramArray.size(); i++) {
						if (HistogramArray.get(i).getRestaurantName().equals(ceo.getRestaurantName())) {
							flag = true;
							double a = HistogramArray.get(i).getInCome();
							HistogramArray.get(i).setInCome(InCome + a);
						}
					}
					if (!flag) {
						HistogramArray.add(ceo);
					}
				}
				Statement stmt4;
				stmt4 = conn.createStatement();
				String ord = "Order";
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
						+ "' and Month='" + month + "' and Year='" + year1 + "' and Type='" + ord + "'");
				if (rs4.next()) {
					int ordID = rs4.getInt(5);
					Statement stmt5;
					stmt5 = conn.createStatement();
					ResultSet rs5 = stmt5
							.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ordID + "'");
					while (rs5.next()) {
						String RN = rs5.getString(2);
						int b = rs5.getInt(4);
						System.out.println("Printing B");
						System.out.println(b);
						for (int i = 0; i < HistogramArray.size(); i++) {
							if (HistogramArray.get(i).getRestaurantName().equals(RN)) {
								int a = HistogramArray.get(i).getSold();
								System.out.println("Printing a");
								System.out.println(a);
								HistogramArray.get(i).setSold(a + b);
								System.out.println("END");
								System.out.println(HistogramArray.get(i).getSold());
							}
						}
					}
				}
			}
		}
		return "Done";

	}

	public static String GetReport(String location, int month, int year, String type) throws SQLException {
		boolean flag = false;
		if (year > EchoServer.Year) {
			return "NotPassed";
		}
		if (month > EchoServer.Month && year == EchoServer.Year) {
			return "NotPassed";
		}
		incomearr = new ArrayList<InComeReport>();
		ordersReport = new ArrayList<OrdersReport>();
		PerfReport = new ArrayList<PerformenceReport>();
		Statement stmt;
		Statement stmt5;
		stmt = conn.createStatement();
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.reports where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + month + "' and Type ='" + type + "'");
		while (rs1.next() == true) {
			flag = true;
			if (type.equals("InCome")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs2.next() == true) {
					InComeReport income = new InComeReport(rs2.getString(2), rs2.getDouble(3));
					incomearr.add(income);
				}
				System.out.println(incomearr.toString());
			}
			if (type.equals("Order")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ID + "'");
				while (rs2.next() == true) {
					OrdersReport orderReport = new OrdersReport(rs2.getString(2), rs2.getString(3), rs2.getInt(4));
					ordersReport.add(orderReport);
				}
				System.out.println(ordersReport.toString());
			}
		}
		if (flag) {
			return "Done";
		}
		if (type.equals("Performence")) {
			stmt5 = conn.createStatement();
			ResultSet rs11 = stmt5
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs11.next()) {
				flag = true;
				String ResName = rs11.getString(2);
				stmt = conn.createStatement();
				ResultSet rs12 = stmt.executeQuery("SELECT * FROM assignment3.performencereports where RestaurantName='"
						+ ResName + "' and Year='" + year + "' and Month ='" + month + "'");
				while (rs12.next()) {
					Time order = rs12.getTime(3);
					Time arrival = rs12.getTime(4);
					int Diff = order.compareTo(arrival);
					if (Diff == 1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Early");
						PerfReport.add(perf);
					}
					if (Diff == 0) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Exactly");
						PerfReport.add(perf);
					}
					if (Diff == -1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Late");
						PerfReport.add(perf);
					}
				}
			}

		}
		System.out.println(PerfReport);
		if (PerfReport.size() == 0 && flag == true) {
			return "NotOpened";
		}
		if (flag) {
			return "Done";
		}
		return "NotOpened";
	}

	static void CreateInComeReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		incomearr = new ArrayList<InComeReport>();
		double income = 0;
		try {
			Statement stmt1 = conn.createStatement();
			Statement stmt2 = conn.createStatement();
			Statement stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				income = 0;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int ItemID = Integer.parseInt(rs2.getString(2));
					int sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						income += sold * rs3.getDouble(3);
					}
				}
				InComeReport ICR = new InComeReport(RestaurantName, income);
				incomearr.add(ICR);
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "InCome");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < incomearr.size(); i++) {
				String query1 = " insert into assignment3.incomereports (ID,RestaurantName,InCome)"
						+ " values (?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, incomearr.get(i).getRestaurantName());
				preparedStmt1.setDouble(3, incomearr.get(i).getIncome());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}

	static void CreateOrdersReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		boolean flag2 = false;
		Statement stmt1;
		Statement stmt2;
		Statement stmt3;
		ordersReport = new ArrayList<OrdersReport>();
		try {
			stmt1 = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int sold = rs2.getInt(3);
					int ItemID = Integer.parseInt(rs2.getString(2));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						String Catalog = rs3.getString(4);
						OrdersReport Order = new OrdersReport(RestaurantName, Catalog, sold);
						for (int i = 0; i < ordersReport.size(); i++) {
							if (ordersReport.get(i).getRestaurantName().equals(Order.getRestaurantName())
									&& ordersReport.get(i).getCatalog().equals(Order.getCatalog())) {
								ordersReport.get(i).setSold(ordersReport.get(i).getSold() + Order.getSold());
								flag2 = true;
							}
						}
						if (!flag2)
							ordersReport.add(Order);
						flag2 = false;
					}
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "Order");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < ordersReport.size(); i++) {
				String query1 = " insert into assignment3.ordersreport (ID,RestaurantName,Catalog,Sold)"
						+ " values (?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, ordersReport.get(i).getRestaurantName());
				preparedStmt1.setString(3, ordersReport.get(i).getCatalog());
				preparedStmt1.setInt(4, ordersReport.get(i).getSold());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}
/////////////////////////////////////////////////////////////////

	public static void insidealldatafromBiteMeDB() throws SQLException {
		userfrombitemedata = new ArrayList<User>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From biteme_data.users");
		User user = null;
		while (RS.next()) {
			try {
				user = new User(RS.getString(1), RS.getString(4), RS.getString(5), RS.getString(8), RS.getString(2),
						RS.getString(6), RS.getString(7), RS.getString(3), RS.getString(14), RS.getString(13), 0,
						Integer.parseInt(RS.getString(11)), RS.getString(12), Integer.parseInt(RS.getString(10)),
						Integer.parseInt(RS.getString(15)));
				userfrombitemedata.add(user);
				String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
						+ " values (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setString(1, user.getID());
				preparedStmt.setString(2, user.getUserName());
				preparedStmt.setString(3, user.getPassword());
				preparedStmt.setString(4, user.getUserType());
				preparedStmt.setInt(5, 0);
				preparedStmt.setInt(6, user.getConfirm());
				preparedStmt.setString(7, user.getStatus());
				preparedStmt.execute();
			} catch (Exception e) {
				System.out.println("importing data ...");
			}
			switch (user.getUserType()) {
			case "BranchManager":
				String query1 = " insert into assignment3.branchmanager (ID,FirstName,LastName,Email,PhoneNumber,location)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setString(1, user.getID());
				preparedStmt1.setString(2, user.getFirstname());
				preparedStmt1.setString(3, user.getLastname());
				preparedStmt1.setString(4, user.getEmail());
				preparedStmt1.setString(5, user.getPhonenumber());
				preparedStmt1.setString(6, user.getLocation());
				preparedStmt1.execute();
				break;
			case "Normal":
				String query2 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
				preparedStmt2.setString(1, user.getID());
				preparedStmt2.setString(2, user.getFirstname());
				preparedStmt2.setString(3, user.getLastname());
				preparedStmt2.setString(4, user.getEmail());
				preparedStmt2.setString(5, user.getPhonenumber());
				preparedStmt2.setInt(6, user.getVisaavailable());
				preparedStmt2.execute();
				break;
			case "Bussiness":
				String query3 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt3 = conn.prepareStatement(query3);
				preparedStmt3.setString(1, user.getID());
				preparedStmt3.setString(2, user.getFirstname());
				preparedStmt3.setString(3, user.getLastname());
				preparedStmt3.setString(4, user.getEmail());
				preparedStmt3.setString(5, user.getPhonenumber());
				preparedStmt3.setString(6, user.getCompany());
				preparedStmt3.execute();
				break;
			case "CEO":
				String query4 = " insert into assignment3.ceouser (ID,FirstName,LastName,Email,PhoneNumber)"
						+ " values (?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
				preparedStmt4.setString(1, user.getID());
				preparedStmt4.setString(2, user.getFirstname());
				preparedStmt4.setString(3, user.getLastname());
				preparedStmt4.setString(4, user.getEmail());
				preparedStmt4.setString(5, user.getPhonenumber());
				preparedStmt4.execute();
				break;
			case "RestaurantManager":
				String query5 = " insert into assignment3.restaurantmanager (ID,FirstName,LastName,Email,PhoneNumber,IDRestaurant)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt5 = conn.prepareStatement(query5);
				preparedStmt5.setString(1, user.getID());
				preparedStmt5.setString(2, user.getFirstname());
				preparedStmt5.setString(3, user.getLastname());
				preparedStmt5.setString(4, user.getEmail());
				preparedStmt5.setString(5, user.getPhonenumber());
				preparedStmt5.setInt(6, user.getIdrestaurant());
				preparedStmt5.execute();
				break;
			case "HR":
				Statement stmt;
				String query6 = " insert into assignment3.hruser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
				preparedStmt6.setString(1, user.getID());
				preparedStmt6.setString(2, user.getFirstname());
				preparedStmt6.setString(3, user.getLastname());
				preparedStmt6.setString(4, user.getEmail());
				preparedStmt6.setString(5, user.getPhonenumber());
				preparedStmt6.setString(6, user.getCompany());
				preparedStmt6.execute();

				break;
			case "Worker":
				String query7 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt7 = conn.prepareStatement(query7);
				preparedStmt7.setString(1, user.getID());
				preparedStmt7.setString(2, user.getFirstname());
				preparedStmt7.setString(3, user.getLastname());
				preparedStmt7.setString(4, user.getEmail());
				preparedStmt7.setString(5, user.getPhonenumber());
				preparedStmt7.setInt(6, user.getIdrestaurant());
				preparedStmt7.execute();

				break;
			}
		}
	}

	public static void deletealldata() throws SQLException {
		Statement ps = conn.createStatement();

		PreparedStatement st, st1, st2 = null, st3 = null;

		ResultSet rs = ps.executeQuery("SELECT * FROM assignment3.users where confirm=0");
		while (rs.next() == true) {
			String ID = rs.getString(1);
			String type = rs.getString(4);

			if (type.equals("Normal")) {
				st = conn.prepareStatement("DELETE FROM assignment3.normaluser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("Bussiness")) {
				st = conn.prepareStatement("DELETE FROM assignment3.bussinessuser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("BranchManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.branchmanager");
				st.executeUpdate();
			} else if (type.equals("CEO")) {
				st = conn.prepareStatement("DELETE FROM assignment3.ceouser");
				st.executeUpdate();
			} else if (type.equals("RestaurantManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantmanager");
				st.executeUpdate();
			} else if (type.equals("HR")) {
				st = conn.prepareStatement("DELETE FROM assignment3.hruser");
				st.executeUpdate();
			} else if (type.equals("Worker")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker");
				st.executeUpdate();
			}
		}
		st = conn.prepareStatement("DELETE FROM assignment3.users WHERE confirm = ?");
		st.setInt(1, 0);
		st.executeUpdate();
	}

	// public WorkerUser(String userID, String firstName, String lastName, String
	// userName, String password, String email,
	// String phoneNumber, int iDRestaurant) {
	public static void LogOutAllAccounts() throws SQLException {
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? ");
		ps.setInt(1, 0);
		ps.executeUpdate();
	}

	public static String AddNewUser(User user, Object msgData1, String table) throws SQLException {
		PreparedStatement st;
		try {
			Statement stmt = conn.createStatement();

			ResultSet rs1 = stmt
					.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			ResultSet rs3 = stmt.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs3.next() == true) {
				return "IDAlreadyExists";
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		if (table.equals("normaluser")) {
			W4CNormal w4c = (W4CNormal) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, user.getID());
			preparedStmt1.setString(2, user.getFirstname());
			preparedStmt1.setString(3, user.getLastname());
			preparedStmt1.setString(4, user.getEmail());
			preparedStmt1.setString(5, user.getPhonenumber());
			preparedStmt1.setInt(6, user.getVisaavailable());
			preparedStmt1.execute();

			String query6 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
			preparedStmt6.setString(1, code);
			preparedStmt6.setString(2, w4c.getUser().getID());
			preparedStmt6.execute();

		} else {
			W4CBussiness w4c = (W4CBussiness) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query2 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, user.getID());
			preparedStmt2.setString(2, user.getFirstname());
			preparedStmt2.setString(3, user.getLastname());
			preparedStmt2.setString(4, user.getEmail());
			preparedStmt2.setString(5, user.getPhonenumber());
			preparedStmt2.setString(6, user.getCompany());
			preparedStmt2.execute();

			String query4 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
			preparedStmt4.setString(1, code);
			preparedStmt4.setDouble(2, w4c.getMoney());
			preparedStmt4.setString(3, w4c.getUser().getID());
			preparedStmt4.execute();

		}
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? , UserType=? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, user.getUserType());
		ps.setString(4, user.getID());
		ps.executeUpdate();

		return "updated";
	}

	public static String AddNewUserwithvisa(User user, Object msgData1, Visa visa, String table) throws SQLException {
		String str = AddNewUser(user, msgData1, table);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.normaluser SET VisaIsAvailable= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, user.getID());
		ps.executeUpdate();

		return str;
	}

	public static void confirmCompane(String cname) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where companyname='" + cname + "'");
		if (rs.next() != true) {
			String query1 = " insert into assignment3.company (companyname,confirm)" + " values (?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, cname);
			preparedStmt1.setInt(2, 0);
			preparedStmt1.execute();
		}
	}

	public static void companyConfirm(String cname) throws SQLException {
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.company SET confirm= ? WHERE companyname = ?");
		ps.setInt(1, 1);
		ps.setString(2, cname);
		ps.executeUpdate();
	}

	public static ArrayList<Company> getCompanyList() {
		Statement stmt;
		CompanyList = new ArrayList<Company>();
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where confirm='" + 0 + "'");
			while (rs.next() == true) {
				Company company = new Company(rs.getString(1), rs.getInt(2));
				CompanyList.add(company);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return CompanyList;
	}

	public static ArrayList<User> TakeAllUserThatNotConfiredyet() throws SQLException {
		TakeAllUserThatNotConfiredyet = new ArrayList<>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From assignment3.users where UserType= 'null'");
		User users;
		while (RS.next()) {
			String id = RS.getString(1);

			for (int i = 0; i < userfrombitemedata.size(); i++) {
				if (id.equals(userfrombitemedata.get(i).getID())) {
					TakeAllUserThatNotConfiredyet.add(userfrombitemedata.get(i));
				}
			}
		}
		return TakeAllUserThatNotConfiredyet;
	}

	public static ArrayList<Company> GetallAvailableCompany() throws SQLException {
		companys = new ArrayList<Company>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.company where confirm=1");
		Company company;
		while (RS.next()) {
			company = new Company(RS.getString(1), Integer.parseInt(RS.getString(2)));
			companys.add(company);
		}
		return companys;

	}

	///////////////
	public static ArrayList<Order> GetAllOrder(int id) throws NumberFormatException, SQLException {
		AllOrder = new ArrayList<Order>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.order where RestaurantID='" + id + "'");
		Order order;
		while (RS.next()) {
			order = new Order(Integer.parseInt(RS.getString(1)), Double.parseDouble(RS.getString(5)), RS.getString(4),
					RS.getString(6), RS.getString(3));
			AllOrder.add(order);
		}
		return AllOrder;
	}

	/////////////////////
	public static void UpdateItem(Item item, String str) throws SQLException {
		PreparedStatement ps, ps1;
		ps1 = conn.prepareStatement("UPDATE assignment3.menu SET quantity= ? WHERE Item_ID = ?");
		ps1.setInt(1, item.getQuantity());
		ps1.setInt(2, item.getItem_ID());
		ps1.executeUpdate();
		ps = conn.prepareStatement("UPDATE assignment3.item SET Item_name= ?, Item_price=? WHERE Item_ID = ?");
		ps.setString(1, item.getItem_Name());
		ps.setDouble(2, item.getPrice());
		ps.setInt(3, item.getItem_ID());
		ps.executeUpdate();

	}

//////////////////
	public static void RemoveItem(Item item) throws SQLException {
		PreparedStatement st, st1;
		st1 = conn.prepareStatement("DELETE FROM assignment3.menu WHERE Item_ID = ?");
		st1.setInt(1, item.getItem_ID());
		st1.executeUpdate();
		st = conn.prepareStatement("DELETE FROM assignment3.item WHERE Item_ID = ?");
		st.setInt(1, item.getItem_ID());
		st.executeUpdate();

	}

	//////////////////
	public static void RemoveItemAddition(Item item, String addition) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.item_addition WHERE name=? and Item_ID = ?");
		st.setString(1, addition);
		st.setInt(2, item.getItem_ID());
		st.executeUpdate();

		st1 = conn.prepareStatement("DELETE FROM assignment3.addition WHERE name = ?");
		st1.setString(1, addition);
		st1.executeUpdate();

	}

	/////////////////
	public static void AddItems(Item item, Addition addition, int resid, String str) throws SQLException {
		if (addition == null) {
			String query = " insert into assignment3.item (item_ID,Item_name,Item_price,category)"
					+ " values (?, ?,?,?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, item.getItem_ID());
			preparedStmt.setString(2, item.getItem_Name());
			preparedStmt.setDouble(3, item.getPrice());
			preparedStmt.setString(4, str);
			preparedStmt.execute();
			String query1 = " insert into assignment3.menu (IDRestaurant,item_ID,quantity)" + " values (?, ?,?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setInt(1, resid);
			preparedStmt1.setInt(2, item.getItem_ID());
			preparedStmt1.setInt(3, item.getQuantity());
			preparedStmt1.execute();
		} else {
			String query = " insert into assignment3.addition (name)" + " values (?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, addition.getName());
			preparedStmt.execute();
			String query2 = " insert into assignment3.item_addition (item_ID,name)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setInt(1, item.getItem_ID());
			preparedStmt2.setString(2, addition.getName());
			preparedStmt2.execute();

		}
	}

	public static ArrayList<WorkerUser> GetAllWorkers(int id) throws Exception// get all worker
	{
		ArrayList<WorkerUser> allworker = new ArrayList<WorkerUser>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		WorkerUser WorkerUser;
		ResultSet RS = ps
				.executeQuery("SELECT * From assignment3.restaurantworker where restaurantWorker='" + id + "'");
		while (RS.next()) {
			String idres = RS.getString(1);
			ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.users where ID='" + idres + "'");
			if (RS1.next()) {
				WorkerUser = new WorkerUser(RS1.getString(1), RS.getString(2), RS.getString(3), RS1.getString(2),
						RS1.getString(3), RS.getString(4), RS.getString(5), id);
				WorkerUser.setRestaurantName(getrestaurantname(id).getResturaunt_Name());
				allworker.add(WorkerUser);

			}
		}
		return allworker;
	}

	public static void UpdateStatusOfUsers(User user1) throws SQLException {
		// System.out.println("user status updated ...." + user1.getUserName());
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET status= ? WHERE ID = ?");
		ps.setString(1, user1.getStatus());
		ps.setString(2, user1.getID());
		ps.executeUpdate();

	}

	public static void BussinessAccountHasBeenAccepted(User user) throws SQLException {/// this method that accepted
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setString(1, "1");
		ps.setString(2, "Active");

		ps.setString(3, user.getID());
		ps.executeUpdate();
	}

	// add new business account
	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser, String str)
			throws SQLException {

		System.out.println("i am getting into login query");
		try {
			Statement stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}

			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, str);
			preparedStmt2.setFloat(2, bussinessUser.getW4C());
			preparedStmt2.setString(3, bussinessUser.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	// add new bussiness account with visa
	static String InsertNewBussinessAccountWithVisa(Visa visa, User user, BussinessUser bussinessUser, String str)
			throws SQLException {
		String value = InsertNewBussinessAccount(user, bussinessUser, str);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		return value;

	}

	static int IDForW4C() {
		Random rand = new Random();
		Statement stmt, stmt1;
		try {
			while (true) {
				int W4C = rand.nextInt((999 - 100) + 1) + 100;
				stmt = conn.createStatement();
				stmt1 = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cnormal where code= '" + W4C + "'");
				if (!rs.next()) {
					ResultSet rs1 = stmt
							.executeQuery("SELECT * FROM assignment3.w4cbussiness where code= '" + W4C + "'");
					if (!rs1.next()) {
						System.out.println(W4C);
						return W4C;
					}
				}
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return 5;
	}

//////////////////////
	public static void RefundCustomer(int number) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		stmt1= conn.createStatement();

		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.order where orderNum='"+number+"'");
		if (rs.next() == true) {
			String userid=rs.getString(3);
			ResultSet rs1= stmt1.executeQuery("SELECT * FROM assignment3.users where ID='"+userid+"'");
			if (rs1.next() == true) {
				String type=rs1.getString(4);
				if(type.equals("Bussiness"))
				{
					Double price=rs.getDouble(5);
					price*0.5
				}
			}
		}
	}

	static String LogInChecker(User username) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where UserName='" + username.getUserName()
				+ "' and Password='" + username.getPassword() + "'");
		if (rs.next() == true) {
			if (rs.getInt(5) == 1)
				return "LoggedIn";

			if (rs.getString(7).equals("Locked")) {
				return "Locked";
			}
			LoginUser = new User(rs.getString(1), username.getUserName(), rs.getString(3), rs.getString(4),
					Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
			return "Entered";
		}
		return "NotExist";
	}

	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser) throws SQLException {
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	static User selectuserfromNormalUserTable(User username) {// check if the password and the user name is correct , if
		// yes then send the
// right message

		Statement stmt;
		int status;
		boolean valid = false;
		String usernameStatus;
		String Status;
		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + username.getID() + "'");
			if (rs.next() == true) {
				Status = rs.getString(10);
				user = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));

				usernameStatus = username.getUserName();
				status = rs.getInt("IsLoggedIn");
			}
			return user;

		} catch (SQLException e) {
			e.printStackTrace();
		}

		return null;

	}

	public static void AcceptNewNormalUser(User username) throws SQLException {
		System.out.println(username.getID());
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, username.getID());
		ps.executeUpdate();
	}

	public static void updateClientStatus(User user, int status) {
		System.out.println("user status updated ...." + user.getUserName());
		PreparedStatement ps, rs;
		try {
			ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? WHERE UserName = ?");
			ps.setInt(1, status);
			ps.setString(2, user.getUserName());

			if (ps.executeUpdate() != 0) {
				System.out.println("update " + user.getUserName() + " status to:" + status);

			} else {
				rs = conn.prepareStatement("UPDATE bitemeuser SET IsLoggedIn= ? WHERE UserName = ?");
				rs.setInt(1, status);
				rs.setString(2, user.getUserName());
				rs.executeUpdate();
			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static void deleteId(String id, String sqltable) throws SQLException {
		PreparedStatement st, st1, st2 = null, st3 = null;
		if (sqltable.equals("normaluser")) {
			st = conn.prepareStatement("DELETE FROM assignment3.normaluser WHERE ID = ?");
			st.setString(1, id);
			st.executeUpdate();
			st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
			st1.setString(1, id);
			st1.executeUpdate();
		}
		if (sqltable.equals("restaurant")) {
			st = conn.prepareStatement("DELETE FROM assignment3.restaurant WHERE IDRestaurant = ?");
			st.setInt(1, Integer.parseInt(id));
			st.executeUpdate();
		} else
			st3 = conn.prepareStatement("DELETE FROM assignment3.bussinessuser WHERE ID = ?");
		st3.setString(1, id);
		st3.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st2.setString(1, id);
		st2.executeUpdate();

	}

	static boolean getTheRequestList(String company) {
		requestsList = new ArrayList<BussinessUser>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps
					.executeQuery("SELECT * From assignment3.users where UserType='Bussiness' and status='Frozen'");
			BussinessUser request;
			while (RS.next()) {
				String id = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery(
						"SELECT * From assignment3.bussinessuser where ID='" + id + "'and Company='" + company + "'");
				if (RS1.next()) {
					request = new BussinessUser(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), 0, RS1.getString(6), 0);
					requestsList.add(request);

				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static boolean getAllUsers() {
		getlistofnormalaccount = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from assignment3.users where UserType= 'Normal' and confirm = 1");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				getlistofnormalaccount.add(request);
				System.out.print(getlistofnormalaccount);
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static void putdatafrombitemeDB() {////////////////////////////////////////////////////////////////////////// WTF
		usersfromBiteMeDB = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void isidedatafrombmtosassignment(ArrayList<User> user) {
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}
			System.out.print(usersfromBiteMeDB);

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void getAllResturaunt(String location) {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant where location='" + location + "'");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static void getAllResturaunt() {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static ArrayList<RestaurantReport> GetReportForManager(int restaurantID, int month, int year)
			throws SQLException {
		ReportListForManager = new ArrayList<RestaurantReport>();
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;
		int month2 = month + 2;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();
			ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='" + restaurantID
					+ "' and Month>='" + month + "' and Month <='" + month2 + "' and Year='" + year + "'");
			System.out.println("dd");
			while (rs2.next() == true) {
				System.out.println("jj");
				ItemID = Integer.parseInt(rs2.getString(2));
				sold = Integer.parseInt(rs2.getString(3));
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
				System.out.println(ItemID);
				System.out.println(restaurantID);
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='" + restaurantID
						+ "' and Item_ID= '" + ItemID + "'");
				if (rs4.next() == true) {
					quantity1 = Integer.parseInt(rs4.getString(3));
					System.out.println(quantity1);
				}
				while (rs3.next() == true) {
					System.out.println("tat");
					System.out.println("Babi");
					rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1, Float.parseFloat(rs3.getString(3)),
							sold, sold * Float.parseFloat(rs3.getString(3)));
					System.out.println("add");
					ReportListForManager.add(rsp);
					System.out.println("ZZZZ");
				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println(ReportListForManager);

		return ReportListForManager;
	}

	public static W4CBussiness getW4CBussiness(User user) {
		W4CBussiness w4c = null;
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cbussiness where IDuser=" + user.getID());
			if (rs.next()) {
				w4c = new W4CBussiness(rs.getInt(1), user, rs.getDouble(2));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return w4c;
	}

	static RestaurantManager GetRestaurantManager(User user) {
		Statement stmt, stmt1;
		int status;
		try {
			stmt1 = conn.createStatement();
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");

				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.restaurant where IDRestaurant='"
						+ Integer.parseInt(rs.getString(6)) + "'");
				if (rs1.next() == true) {
					restaurantManager = new RestaurantManager(rs.getString(1), rs.getString(2), rs.getString(3),
							rs.getString(4), rs.getString(5), Integer.parseInt(rs.getString(6)));
					System.out.println(restaurantManager);

					return restaurantManager;
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static void deleteOrder(int orderid) {
		Statement stmt;
		try {
			String SQL = "delete from assignment3.order where orderNum=?";
			PreparedStatement pstmt = null;

			// get a connection and then in your try catch for executing your delete...

			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_items where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_item_addition where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static boolean CheckDelivery(int orderid) {
		String sql = "select COUNT(*) from assignment3.delivery where orderNum=" + orderid;
		Statement st = null;
		try {
			st = conn.createStatement();
			ResultSet rs = st.executeQuery(sql);
			if (rs.next() == true) {
				String SQL = "delete from assignment3.delivery where orderNum=?";
				PreparedStatement pstmt = null;
				pstmt = conn.prepareStatement(SQL);
				pstmt.setInt(1, orderid);
				pstmt.executeUpdate();
				return true;
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	public static String GetDeliveryDate(int orderid) {
		Statement stmt;
		String date = "";
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("select * from assignment3.delivery where orderNum=" + orderid);
			date = rs.getString(6);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return date;
	}

	static WorkerUser GetRestaurantWorker(User user) {///////////////////////////////////////////
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantworker where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");
				WorkerUser = new WorkerUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return WorkerUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	private static String getitemname(int itemid) throws SQLException {
		Statement stmt, stmt1;
		stmt1 = conn.createStatement();
		String str = null;
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + itemid + "'");
		if (rs1.next() == true) {
			str = rs1.getString(2);

		}
		return str;
	}

/////////////////////////////////////
	public static ArrayList<ItemAddition> GetallOrederItems(int ordernum) throws SQLException {
		Statement stmt, stmt1;

		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ArrayList<ItemAddition> itemsandAddition1 = new ArrayList<>();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.order_item_addition where orderNum='" + ordernum + "'");
		while (rs.next()) {
			int itemid = rs.getInt(2);
			String str = rs.getString(3);
			ItemAddition a = (new ItemAddition(getitemname(itemid), str));
			itemsandAddition1.add(a);
		}
		System.out.print("****&****");
		System.out.print(itemsandAddition1);
		return itemsandAddition1;
	}

	public static String getuser(String id) throws SQLException {
		Statement stmt, stmt1;
		int status;
		String mail = null;
		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + id + "'");
		if (rs.next() == true) {
			String type = rs.getString(4);
			switch (type) {
			case "Normal":
				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + id + "'");
				if (rs1.next() == true) {
					mail = rs1.getString(4);
					return mail;
				}
				break;
			case "Bussiness":
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + id + "'");
				if (rs2.next() == true) {
					mail = rs2.getString(4);
					return mail;
				}
				break;

			}
		}
		return mail;
	}

	static BranchManager GetBranchManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.branchmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				branchManager = new BranchManager(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6));
				return branchManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static CEOuser CeoUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.ceouser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				CEOuser1 = new CEOuser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5));
				return CEOuser1;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static BussinessUser GetBissnessUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				W4CBussiness w4c = getW4CBussiness(user);
				BussinessUser = new BussinessUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6), w4c);
				return BussinessUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding BissessUser!!!");
		return null;
	}

	static Resturaunt getrestaurantname(int id) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT *  FROM assignment3.restaurant where IDRestaurant= " + id);
		if (rs.next() == true) {
			Resturaunt = new Resturaunt(Integer.parseInt(rs.getString(1)), rs.getString(2), rs.getString(3));
			return Resturaunt;
		}
		return null;

	}

	static HRUser GetHRManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.hruser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				HRManager = new HRUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(6));
				return HRManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static Normal getNormalUser(User user) throws SQLException {
		Normal nuser = null;

		Statement st;
		ResultSet rs = null;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("Select * from assignment3.normaluser where ID=" + user.getID());
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		if (rs.next()) {
			try {
				nuser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5));
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return nuser;

	}

	public static Normal Getnormaluser(User user) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				Normaluser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return Normaluser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;
	}

	public static ArrayList<RestaurantReport> GetReportForRestaurant(RestaurantManager restaurantManager, int month,
			int year) throws SQLException {
		ReportList = new ArrayList<RestaurantReport>();
		Statement stmt;
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;

		int IDRestaurant;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();

			System.out.println("aa");
			System.out.println(restaurantManager.getUserName());

			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.restaurantmanager where ID='" + restaurantManager.getUserID() + "'");
			System.out.println("bb");
			if (rs.next() == true) {
				System.out.println("cc");
				IDRestaurant = Integer.parseInt(rs.getString(6));
				System.out.println(IDRestaurant);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				System.out.println("dd");
				while (rs2.next() == true) {
					System.out.println("jj");
					ItemID = Integer.parseInt(rs2.getString(2));
					sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='"
							+ IDRestaurant + "' and Item_ID= '" + ItemID + "'");
					if (rs4.next() == true) {
						quantity1 = Integer.parseInt(rs4.getString(3));
						System.out.println(quantity1);
					}
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					System.out.println("mm");
					while (rs3.next() == true) {
						System.out.println("tat");
						rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1,
								Float.parseFloat(rs3.getString(3)), sold, sold * Float.parseFloat(rs3.getString(3)));
						System.out.println("add");
						ReportList.add(rsp);
						System.out.println("ZZZZ");
					}

				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("z");
		return ReportList;
	}

	public static String AddNewWorker(WorkerUser WorkerUser) throws SQLException {
		Statement stmt;

		stmt = conn.createStatement();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.users where UserName='" + WorkerUser.getUserName() + "'");
		if (rs.next() == true) {
			return "UserNameAlreadyExists";
		}
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + WorkerUser.getUserID() + "'");
		if (rs1.next() == true) {
			return "IDAlreadyExists";
		}
		String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
				+ " values (?, ?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt = conn.prepareStatement(query);
		preparedStmt.setString(1, WorkerUser.getUserID());
		preparedStmt.setString(2, WorkerUser.getUserName());
		preparedStmt.setString(3, WorkerUser.getPassword());
		preparedStmt.setString(4, "Worker");
		preparedStmt.setInt(5, 0);
		preparedStmt.setInt(6, 1);
		preparedStmt.setString(7, "Active");
		preparedStmt.execute();

		String query1 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, WorkerUser.getUserID());
		preparedStmt1.setString(2, WorkerUser.getFirstName());
		preparedStmt1.setString(3, WorkerUser.getLastName());
		preparedStmt1.setString(4, WorkerUser.getEmail());
		preparedStmt1.setString(5, WorkerUser.getPhoneNumber());
		preparedStmt1.setInt(6, WorkerUser.getIDRestaurant());
		preparedStmt1.execute();
		return "Updated";

	}

	public static void RemoveWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker  WHERE ID = ?");
		st.setString(1, WorkerUser.getUserID());
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st1.setString(1, WorkerUser.getUserID());
		st1.executeUpdate();
	}

	public static void EditWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement ps, rs;

		ps = conn.prepareStatement(
				"UPDATE assignment3.restaurantworker SET FirstName= ?,LastName=?,Email=?,PhoneNumber=?  WHERE ID = ?");
		ps.setString(1, WorkerUser.getFirstName());
		ps.setString(2, WorkerUser.getLastName());
		ps.setString(3, WorkerUser.getEmail());
		ps.setString(4, WorkerUser.getPhoneNumber());
		ps.setString(5, WorkerUser.getUserID());
		ps.executeUpdate();
		rs = conn.prepareStatement("UPDATE assignment3.users SET UserName= ?,Password=? WHERE ID = ?");
		rs.setString(1, WorkerUser.getUserName());
		rs.setString(2, WorkerUser.getPassword());
		rs.setString(3, WorkerUser.getUserID());
		rs.executeUpdate();

	}

	public static String Create_acceptRestaurant(Resturaunt res) throws SQLException {
		PreparedStatement ps;
		try {
			String query1 = " insert into assignment3.restaurant (IDRestaurant,RestaurantName,location)"
					+ " values (?, ?, ?)";
			ps = conn.prepareStatement(query1);
			ps.setInt(1, res.getResturauntID());
			ps.setString(2, res.getResturaunt_Name());
			ps.setString(3, res.getLocation());
			ps.execute();
		} catch (Exception e) {
			return "This Id is Existes";
		}

		return "updated";

	}

	static boolean GetTheRequestNormalAccount() {
		NormalUsersNotAccepted = new ArrayList<Normal>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * FROM assignment3.users where confirm= 0 ");
			Normal request;
			while (RS.next()) {
				String ID = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + ID + "'");
				while (RS1.next()) {
					request = new Normal(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), Integer.parseInt(RS1.getString(6)), Float.parseFloat(RS1.getString(7)));
					NormalUsersNotAccepted.add(request);
				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	public static void InsertNewNormalAccountWithVisa(Visa visa, User user, Normal NorUser) throws SQLException {
		InsertNewNormalAccountWithOutVisa(user, NorUser);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();

	}

	public static String InsertNewNormalAccountWithOutVisa(User user, Normal NorUser) throws SQLException {
		Statement stmt;

		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, NorUser.getID());
			preparedStmt1.setString(2, NorUser.getFirstName());
			preparedStmt1.setString(3, NorUser.getLastName());
			preparedStmt1.setString(4, NorUser.getEmail());
			preparedStmt1.setString(5, NorUser.getPhoneNumber());
			preparedStmt1.setInt(6, NorUser.getVisaIsAvailable());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, String.valueOf(NorUser.getW4C()));
			preparedStmt2.setString(2, user.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	public static boolean updatePassword(User user) {
		System.out.println("user password updated ...." + user.getUserName());
		PreparedStatement ps;
		try {

			ps = conn.prepareStatement("UPDATE assignment3.users SET Password= ? WHERE ID = ?");
			ps.setString(1, user.getPassword());
			ps.setString(2, user.getID());

			if (ps.executeUpdate() == 0) {
				System.out.println("Table Update Error!");
				return false;
			} else {
				System.out.println("update user with ID:" + user.getID() + " password to " + user.getPassword());
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return true;
	}

	public static String InsertNewBussinessAccount(BussinessUser user) throws SQLException {
		Statement stmt;
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getFirstName());
			preparedStmt.setString(3, user.getLastName());
			preparedStmt.setString(4, user.getPhoneNumber());
			preparedStmt.setString(5, user.getEmail());
			preparedStmt.setString(6, user.getCompany());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	private static ArrayList<Addition> getAdditions(int itemId) {
		String sql = "select * from assignment3.item_addition where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		ArrayList<Addition> list = new ArrayList<Addition>();
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				Addition tmp = new Addition(rs.getString("name"));
				list.add(tmp);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return list;
	}

	// get item for specific menu
	private static Item getItems(int itemId) {
		String sql = "select * from assignment3.item where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		Item item = null;
		ArrayList<Addition> list;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				String cat = rs.getString("category");
				Category c = Category.valueOf(cat.toString());
				list = getAdditions(itemId);
				item = new Item(itemId, rs.getString("Item_name"), rs.getDouble("Item_price"), c, list);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return item;
	}

	// get menu for each restaurant, calls getItems function to get items for menu
	private static Menu getMenu(int ResId) {
		Menu m = null;
		Item item = null;
		Statement st = null;
		HashMap<Item, Integer> items2 = new HashMap<>();
		// ArrayList<Item> items = new ArrayList<>();
		ResultSet rs = null;
		String sql = "select * from assignment3.menu where IDRestaurant=" + ResId;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				int itemId = rs.getInt("Item_ID");
				item = getItems(itemId);
				items2.put(item, rs.getInt("quantity"));
				// items.add(item);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		m = new Menu(items2);
		return m;
	}

	// return all restaurants from data base to display to the client
	public static ArrayList<Resturaunt> getAllResturaunts() {
		ArrayList<Resturaunt> resList = new ArrayList<>();
		ResultSet rs = null;
		PreparedStatement ps = null;
		String sql = "select * from assignment3.restaurant";
		try {
			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				int ResId = rs.getInt("IDRestaurant");
				Menu m = getMenu(ResId);
				Resturaunt r = new Resturaunt(ResId, rs.getString("RestaurantName"), m);
				resList.add(r);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return resList;
	}

	public static String companyChecker(String cname11) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.company where confirm='" + 1 + "' and companyname='" + cname11 + "'");
			if (rs.next() == true) {
				return "companyExist";
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static W4CNormal getW4C(User user) {
		Statement stmt;
		W4CNormal w4c = null;
		String sql = null;
		if (user.getUserType().equals("Normal"))
			sql = "select * from assignment3.w4cnormal where IDuser=" + user.getID();
		else if (user.getUserType().equals("Bussiness"))
			sql = "select * from assignment3.w4cbussiness where IDuser=" + user.getID();

		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			while (rs.next()) {
				if (user.getUserType().equals("Normal")) {
					w4c = new W4CNormal(rs.getInt(1), user);
					user.setW4c(w4c);
					System.out.println(user.getW4c().getCode());
				} else if (user.getUserType().equals("Bussiness")) {
					w4c = new W4CBussiness(rs.getInt(1), user, rs.getInt(2));
					user.setW4c(w4c);
				}
			}
		} catch (SQLException e) {

			e.printStackTrace();
		}
		return w4c;
	}

	public static ArrayList<Item> getallmaindish(int id, String type) throws SQLException {
		Item Items = null;
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Itemss = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					String cat = RS1.getString("category");
					Category c = Category.valueOf(cat.toString());
					addition = GetAllAddition(itemid);
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							(ArrayList<Addition>) addition, Integer.parseInt(RS.getString(3)), c);
					Items.setCate(cat);
					Itemss.add(Items);

				}
			}
			return Itemss;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static ArrayList<Addition> GetAllAddition(int itemid) throws SQLException {
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Addition add;
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("select * from assignment3.item_addition where Item_ID='" + itemid + "'");
		while (RS.next()) {
			add = new Addition(RS.getString(2));
			addition.add(add);
			System.out.println(add + "im here");
		}
		return addition;
	}

	public static ArrayList<Item> getallitems(int id) throws SQLException {
		Item Items = null;

		AllItems = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							Integer.parseInt(RS.getString(3)));
					System.out.print(Items);
					AllItems.add(Items);

				}
			}
			return AllItems;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static void generate_qr(String image_name, String qrCodeData) {
		try {
			System.out.println(image_name + " " + qrCodeData);
			String filePath = "D:\\" + image_name + ".png";
			String charset = "UTF-8"; // or "ISO-8859-1"
			Map<EncodeHintType, ErrorCorrectionLevel> hintMap = new HashMap<EncodeHintType, ErrorCorrectionLevel>();
			hintMap.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);
			BitMatrix matrix = new MultiFormatWriter().encode(new String(qrCodeData.getBytes(charset), charset),
					BarcodeFormat.QR_CODE, 200, 200, hintMap);
			MatrixToImageWriter.writeToFile(matrix, filePath.substring(filePath.lastIndexOf('.') + 1),
					new File(filePath));
			System.out.println("QR Code image created successfully!");
		} catch (Exception e) {
			System.err.println(e);
		}
	}

	@Override
	public void initialize(URL location, ResourceBundle resources) {
		// TODO Auto-generated method stub

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-28 16:25:12.294
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-28 16:25:12.295
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:167)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-28 16:25:12.722
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package server;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.ResourceBundle;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.MultiFormatWriter;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import com.lowagie.text.Document;
import com.lowagie.text.DocumentException;
import com.lowagie.text.pdf.PdfPTable;
import com.lowagie.text.pdf.PdfWriter;
import com.mysql.cj.conf.ConnectionUrl.Type;

import client.ChatClient;
import javafx.fxml.Initializable;
import common.Addition;
import common.BranchManager;
import common.CEOuser;
import common.Category;
import common.Company;
import common.Delivery;
import common.GroupDelivery;
import common.HRUser;
import common.HistogramCEO;
import common.InComeReport;
import common.Item;
import common.ItemAddition;
import common.Menu;
import common.Normal;
import common.Order;
import common.OrdersReport;
import common.PDFList;
import common.PerformenceReport;
import common.RestaurantManager;
import common.RestaurantReport;
import common.Resturaunt;
import common.User;
import common.Visa;
import common.W4CBussiness;
import common.W4CNormal;
import common.BussinessUser;
import common.WorkerUser;

public class mysqlConnection implements Initializable {
	public static User user;
	public static User user1 = null;
	public static ArrayList<String> list;
	public static ArrayList<BussinessUser> requestsList;
	public static ArrayList<User> getlistofnormalaccount;
	public static ArrayList<User> usersfromBiteMeDB;
	public static ArrayList<Item> Itemss;
	public static ArrayList<Item> AllItems;
	public static ArrayList<Company> companys;
	public static ArrayList<Resturaunt> getAllresturaunt;
	public static RestaurantManager restaurantManager;
	public static WorkerUser WorkerUser;
	public static BranchManager branchManager;
	public static HRUser HRManager;
	public static Normal Normaluser;
	public static ArrayList<RestaurantReport> ReportList;
	public static ArrayList<RestaurantReport> ReportListForManager;
	public static Connection conn;
	public static Resturaunt Resturaunt;
	public static ArrayList<Normal> NormalUsersNotAccepted;
	public static BussinessUser BussinessUser;
	public static CEOuser CEOuser1;
	public static ArrayList<User> TakeAllUserThatNotConfiredyet;
	public static ArrayList<User> userfrombitemedata;
	public static ArrayList<Company> CompanyList;
	public static ArrayList<Order> AllOrder;
	public static ArrayList<Item> Allitemsoforders;
	public static ArrayList<ItemAddition> itemsandAddition;
	public static ArrayList<OrdersReport> ordersReport;
	public static ArrayList<InComeReport> incomearr;
	public static ArrayList<PerformenceReport> PerfReport;
	public static ArrayList<HistogramCEO> HistogramArray;
	public static User LoginUser;
	public static int ReportIDCounter = 1;

	@SuppressWarnings("deprecation")
	public static Connection connectToDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}

		try {
			String s1 = "jdbc:mysql://localhost/assignment3?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static Connection connectToBiteMeDB() {

		try {
			Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			System.out.println("Driver definition succeed");
		} catch (Exception ex) {
			/* handle the error */
			System.out.println("Driver definition failed");
		}
//		"jdbc:mysql://localhost/assigment2?serverTimezone=IST", "root","912000bashar"
		try {
			String s1 = "jdbc:mysql://localhost/biteme_data?serverTimezone=IST";
			String s2 = "root";
			String s3 = "Aa123456";
			conn = DriverManager.getConnection(s1, s2, s3);
			System.out.println("SQL connection succeed To BiteMe DB");
			return conn;
		} catch (SQLException ex) {/* handle any errors */
			System.out.println("SQLException: " + ex.getMessage());
			System.out.println("SQLState: " + ex.getSQLState());
			System.out.println("VendorError: " + ex.getErrorCode());
			return null;
		}
	}

	public static void updateW4CforBussiness(BussinessUser user) {
		PreparedStatement ps;

		try {
			ps = conn.prepareStatement("UPDATE assignment3.w4cbussiness SET money= ? WHERE IDuser = ?");
			ps.setDouble(1, user.getW4c().getMoney());
			ps.setString(2, user.getID());
			ps.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static boolean GetGroupNumber(int number) throws SQLException {
		ResultSet rs = null;
		String query = "select * from assignment3.group_delivery where code=" + number;
		Statement st;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(query);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return rs.next();
	}

	public static void InsertGroup(GroupDelivery gp) {
		String sql = "insert into assignment3.group_delivery (code,group_size) values (?,?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(sql);
			preparedStmt.setInt(1, gp.getGroupNum());
			preparedStmt.setInt(2, gp.getGroupSize());
			preparedStmt.execute();
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public static void soldItems(Order solditems) {
		Statement st;
		ResultSet rs = null;
		String sql;
		int soldupdate = 0;
		int updatesold = 0;
		for (int i = 0; i < solditems.getItems().size(); i++) {
			String query2 = "select quantity from assignment3.menu where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and Item_ID=" + solditems.getItems().get(i).getItem_ID();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query2);
				if (rs.next() == true) {
					updatesold = rs.getInt(1);
					updatesold -= solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.menu SET quantity= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and Item_ID="
							+ solditems.getItems().get(i).getItem_ID();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, updatesold);
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}

			String query = "select Sold from assignment3.solditem where IDRestaurant="
					+ solditems.getRes().getResturauntID() + " and ItemID=" + solditems.getItems().get(i).getItem_ID()
					+ " and Month=" + solditems.getMonth() + " and Year=" + solditems.getYear();
			try {
				st = conn.createStatement();
				rs = st.executeQuery(query);
				if (rs.next() == true) {
					soldupdate = rs.getInt(1);
					soldupdate += solditems.getItems().get(i).getQuantity();
					sql = "UPDATE assignment3.solditem SET Sold= ? where IDRestaurant="
							+ solditems.getRes().getResturauntID() + " and ItemID="
							+ solditems.getItems().get(i).getItem_ID() + " and Month=" + solditems.getMonth()
							+ " and Year=" + solditems.getYear();
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, soldupdate);
					preparedStmt.execute();

				} else {
					sql = "insert into assignment3.solditem (IDRestaurant,ItemID,Sold,Month,Year) values (?,?,?,?,?)";
					PreparedStatement preparedStmt = conn.prepareStatement(sql);
					preparedStmt.setInt(1, solditems.getRes().getResturauntID());
					preparedStmt.setInt(2, solditems.getItems().get(i).getItem_ID());
					preparedStmt.setInt(3, solditems.getItems().get(i).getQuantity());
					preparedStmt.setInt(4, solditems.getMonth());
					preparedStmt.setInt(5, solditems.getYear());
					preparedStmt.execute();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

	}

	public static void newDelivery(Delivery del) {
		String query = " insert into assignment3.delivery (deliveryNum,orderNum,name,phonenumber,address,deliveryType,deliveryDate,clientTxt)"
				+ " values (?, ?, ?, ?, ?, ?,?,?)";

		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, del.getDeliveryNum());
			preparedStmt.setInt(2, del.getOrderNum());
			preparedStmt.setString(3, del.getFirstname());
			preparedStmt.setString(4, del.getPhonenumber());
			preparedStmt.setString(5, del.getAddress());
			preparedStmt.setString(6, del.getDeliveryType());
			preparedStmt.setString(7, del.getDate() + " " + del.getHour() + ":" + del.getMinute());
			preparedStmt.setString(8, del.getClientText());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void newOrder(Order order) {
		String query = " insert into assignment3.order (orderNum,RestaurantID,userID,submitDate,totalPrice,pickupTime)"
				+ " values (?, ?, ?, ?, ?, ?)";
		try {
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, order.getOrderNum());
			preparedStmt.setInt(2, order.getRes().getResturauntID());
			preparedStmt.setString(3, order.getUser().getID());
			preparedStmt.setString(4, order.getCurrentDateAndTime());
			preparedStmt.setDouble(5, order.getTotalPrice());
			preparedStmt.setString(6, order.getDate() + " " + order.getHour() + ":" + order.getMinute());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}

		query = "insert into assignment3.order_items (orderNum,item_ID,quantity) values(?,?,?)";
		try {
			for (int i = 0; i < order.getItems().size(); i++) {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, order.getOrderNum());
				preparedStmt.setInt(2, order.getItems().get(i).getItem_ID());
				preparedStmt.setInt(3, order.getItems().get(i).getQuantity());
				preparedStmt.execute();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static void order_items_additions(Object itemAddition) {
		ArrayList<Item> item_addition = (ArrayList<Item>) itemAddition;
		String query = "insert into assignment3.order_item_addition (orderNum,item_ID,name) values (?,?,?)";

		for (Item i : item_addition) {
			try {
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setInt(1, i.getOrderNum());
				preparedStmt.setInt(2, i.getItem_ID());
				preparedStmt.setString(3, i.getAdditions_names());
				// preparedStmt.setInt(4, i.getIndex());
				preparedStmt.execute();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}

	public static int getOrderID() {
		Statement st;
		ResultSet rs = null;
		int orderNum = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order");
			if (rs.next()) {
				orderNum = rs.getInt(1);
				if (orderNum == 0)
					return orderNum;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order ORDER BY orderNum DESC LIMIT 1");
			if (rs.next()) {
				orderNum = rs.getInt(1);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return orderNum;
	}

	public static int getIND() {
		Statement st;
		ResultSet rs = null;
		int ind = 0;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("SELECT COUNT(*) FROM assignment3.order_item_addition");
			if (rs.next()) {
				ind = rs.getInt(1);
				if (ind == 0)
					return ind;
			}
			rs = st.executeQuery("SELECT * FROM assignment3.order_item_addition ORDER BY ind DESC LIMIT 1");
			if (rs.next()) {
				ind = rs.getInt(4);
			}
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return ind;
	}

	public static void DeleteAllReports() throws SQLException {
		Statement ps = conn.createStatement();
		PreparedStatement st, st1, st2, st3;
		st = conn.prepareStatement("DELETE FROM assignment3.ordersreport");
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.reports");
		st1.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.quarterlypdf");
		st2.executeUpdate();
		st3 = conn.prepareStatement("DELETE FROM assignment3.incomereports");
		st3.executeUpdate();
	}

	public static ArrayList<PDFList> PDFLists() throws SQLException {
		System.out.println("First");
		ArrayList<PDFList> PDFListArray = new ArrayList<>();
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Sent='" + 1 + "'");
		while (rs1.next()) {
			PDFList P = new PDFList(rs1.getString(1), rs1.getInt(2), rs1.getString(3));
			PDFListArray.add(P);
		}
		return PDFListArray;
	}

	public static String SendPDFToCeo(String location, int year, String Months) throws SQLException {
		Statement stmt1;
		stmt1 = conn.createStatement();
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.quarterlypdf where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + Months + "'");
		if (rs1.next()) {
			String query = "update assignment3.quarterlypdf set Sent = ? where Location = ? and Year = ? and Month = ?";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, 1);
			preparedStmt.setString(2, location);
			preparedStmt.setInt(3, year);
			preparedStmt.setString(4, Months);
			preparedStmt.executeUpdate();
			return "Updated";
		}
		if (year > EchoServer.Year)
			return "NotPassed";
		if (year < 2021)
			return "NotOpend";
		return null;
	}

	public static void InsertPDFtoDB(int year, int month, String Location)
			throws SQLException, DocumentException, IOException {
		if (month % 3 != 0) {
			return;
		}
		System.out.println("Inserting Q");
		String StringMonth = null;
		ArrayList<PerformenceReport> PReport = new ArrayList<>();
		ArrayList<RestaurantReport> RReport = new ArrayList<>();
		GetReport(Location, month, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 1, year, "Performence");
		PReport.addAll(PerfReport);
		GetReport(Location, month - 2, year, "Performence");
		PReport.addAll(PerfReport);
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.restaurant where Location='" + Location + "'");
		while (rs2.next()) {
			int RestaurantID = rs2.getInt(1);
			RReport.addAll(GetReportForManager(RestaurantID, month - 2, year));
		}
		if (month == 12) {
			StringMonth = "10,11,12";
		}
		if (month == 9) {
			StringMonth = "7,8,9";
		}
		if (month == 6) {
			StringMonth = "4,5,6";
		}
		if (month == 3) {
			StringMonth = "1,2,3";
		}
		String str = Location + String.valueOf(year) + String.valueOf(month);
		Document DocPDF = CreatePDF(PReport, RReport, str);
		String query2 = " insert into assignment3.quarterlypdf (Location,Year,Month,PDF,Sent)"
				+ " values (?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
		preparedStmt2.setString(1, Location);
		preparedStmt2.setInt(2, year);
		preparedStmt2.setString(3, StringMonth);
		InputStream inputStream = new FileInputStream(new File("C:\\G5BiteMe\\Report" + str + ".pdf"));
		preparedStmt2.setBlob(4, inputStream);
		preparedStmt2.setInt(5, 0);
		preparedStmt2.execute();
	}

	public static Document CreatePDF(ArrayList<PerformenceReport> PReport, ArrayList<RestaurantReport> RReport,
			String LYM) throws DocumentException, IOException {
		Document doc = new Document();
		System.out.println("Creating PDF Arrays");
		System.out.println(PReport.toString());
		System.out.println(RReport.toString());
		PdfWriter.getInstance(doc, new FileOutputStream("C:\\G5BiteMe\\Report" + LYM + ".pdf"));
		doc.open();
		PdfPTable tablepdf = new PdfPTable(5);
		tablepdf.addCell("Order ID");
		tablepdf.addCell("Restaurant Name");
		tablepdf.addCell("Order Time");
		tablepdf.addCell("Arrival Time");
		tablepdf.addCell("Condition");
		for (int i = 0; i < PReport.size(); i++) {
			int OrderID = PReport.get(i).getOrderID();
			String StringOrderID = String.valueOf(OrderID);
			String RName = PReport.get(i).getRestaurantName();
			Time OrderTime = PReport.get(i).getOrderTime();
			String OrderTimeString = String.valueOf(OrderTime);
			Time Arrival = PReport.get(i).getArrival();
			String ArrivalString = String.valueOf(Arrival);
			String Condition = PReport.get(i).getCondition();
			tablepdf.addCell(StringOrderID);
			tablepdf.addCell(RName);
			tablepdf.addCell(OrderTimeString);
			tablepdf.addCell(ArrivalString);
			tablepdf.addCell(Condition);
		}
		doc.add(tablepdf);
		doc.newPage();
		PdfPTable tablepdf1 = new PdfPTable(6);
		tablepdf1.addCell("Item ID");
		tablepdf1.addCell("Item Name");
		tablepdf1.addCell("Quantity");
		tablepdf1.addCell("Price per one");
		tablepdf1.addCell("Sold");
		tablepdf1.addCell("InCome");

		for (int i = 0; i < RReport.size(); i++) {
			int ItemID = RReport.get(i).getItemID();
			String StringItemID = String.valueOf(ItemID);
			String ItemName = RReport.get(i).getItemName();
			String Quantity = String.valueOf(RReport.get(i).getQuantity());
			String PerOne = String.valueOf(RReport.get(i).getPrice1());
			String Sold = String.valueOf(RReport.get(i).getSold());
			String InCome = String.valueOf(RReport.get(i).getInCome());

			tablepdf1.addCell(StringItemID);
			tablepdf1.addCell(ItemName);
			tablepdf1.addCell(Quantity);
			tablepdf1.addCell(PerOne);
			tablepdf1.addCell(Sold);
			tablepdf1.addCell(InCome);
		}
		doc.add(tablepdf1);
		doc.close();
		return doc;
	}

	public static String GetHistogram(String area, int year1, String months) throws SQLException {
		HistogramArray = new ArrayList<HistogramCEO>();
		boolean flag = false;
		int month1 = 0;
		int month3 = 0;
		if (months.equals("1,2,3")) {
			month1 = 1;
			month3 = 3;
		}
		if (months.equals("4,5,6")) {
			month1 = 4;
			month3 = 6;
		}
		if (months.equals("7,8,9")) {
			month1 = 7;
			month3 = 9;
		}
		if (months.equals("10,11,12")) {
			month1 = 10;
			month3 = 12;
		}
		if (month3 > EchoServer.Month && year1 == EchoServer.Year) {
			return "NotPassed";
		}
		if (year1 > EchoServer.Year) {
			return "NotPassed";
		}
		if (month3 < 10 && year1 == 2021) {
			return "NotOpend";
		}
		if (year1 < 2021) {
			return "NotOpend";
		}
		Statement stmt2;
		stmt2 = conn.createStatement();
		ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
				+ "' and Month>='" + month1 + "' and Month <='" + month3 + "' and Year='" + year1 + "'");
		while (rs2.next()) {
			String type = rs2.getString(1);
			if (type.equals("InCome")) {
				flag = false;
				int ID = rs2.getInt(5);
				String month = rs2.getString(4);
				Statement stmt3;
				stmt3 = conn.createStatement();
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs3.next()) {
					String RestaurantName = rs3.getString(2);
					double InCome = rs3.getDouble(3);
					HistogramCEO ceo = new HistogramCEO(RestaurantName, InCome, 0);
					for (int i = 0; i < HistogramArray.size(); i++) {
						if (HistogramArray.get(i).getRestaurantName().equals(ceo.getRestaurantName())) {
							flag = true;
							double a = HistogramArray.get(i).getInCome();
							HistogramArray.get(i).setInCome(InCome + a);
						}
					}
					if (!flag) {
						HistogramArray.add(ceo);
					}
				}
				Statement stmt4;
				stmt4 = conn.createStatement();
				String ord = "Order";
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.reports where Location='" + area
						+ "' and Month='" + month + "' and Year='" + year1 + "' and Type='" + ord + "'");
				if (rs4.next()) {
					int ordID = rs4.getInt(5);
					Statement stmt5;
					stmt5 = conn.createStatement();
					ResultSet rs5 = stmt5
							.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ordID + "'");
					while (rs5.next()) {
						String RN = rs5.getString(2);
						int b = rs5.getInt(4);
						System.out.println("Printing B");
						System.out.println(b);
						for (int i = 0; i < HistogramArray.size(); i++) {
							if (HistogramArray.get(i).getRestaurantName().equals(RN)) {
								int a = HistogramArray.get(i).getSold();
								System.out.println("Printing a");
								System.out.println(a);
								HistogramArray.get(i).setSold(a + b);
								System.out.println("END");
								System.out.println(HistogramArray.get(i).getSold());
							}
						}
					}
				}
			}
		}
		return "Done";

	}

	public static String GetReport(String location, int month, int year, String type) throws SQLException {
		boolean flag = false;
		if (year > EchoServer.Year) {
			return "NotPassed";
		}
		if (month > EchoServer.Month && year == EchoServer.Year) {
			return "NotPassed";
		}
		incomearr = new ArrayList<InComeReport>();
		ordersReport = new ArrayList<OrdersReport>();
		PerfReport = new ArrayList<PerformenceReport>();
		Statement stmt;
		Statement stmt5;
		stmt = conn.createStatement();
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.reports where Location='" + location
				+ "' and Year='" + year + "' and Month ='" + month + "' and Type ='" + type + "'");
		while (rs1.next() == true) {
			flag = true;
			if (type.equals("InCome")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.incomereports where ID='" + ID + "'");
				while (rs2.next() == true) {
					InComeReport income = new InComeReport(rs2.getString(2), rs2.getDouble(3));
					incomearr.add(income);
				}
				System.out.println(incomearr.toString());
			}
			if (type.equals("Order")) {
				int ID = rs1.getInt(5);
				Statement stmt1;
				stmt1 = conn.createStatement();
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.ordersreport where ID='" + ID + "'");
				while (rs2.next() == true) {
					OrdersReport orderReport = new OrdersReport(rs2.getString(2), rs2.getString(3), rs2.getInt(4));
					ordersReport.add(orderReport);
				}
				System.out.println(ordersReport.toString());
			}
		}
		if (flag) {
			return "Done";
		}
		if (type.equals("Performence")) {
			stmt5 = conn.createStatement();
			ResultSet rs11 = stmt5
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs11.next()) {
				flag = true;
				String ResName = rs11.getString(2);
				stmt = conn.createStatement();
				ResultSet rs12 = stmt.executeQuery("SELECT * FROM assignment3.performencereports where RestaurantName='"
						+ ResName + "' and Year='" + year + "' and Month ='" + month + "'");
				while (rs12.next()) {
					Time order = rs12.getTime(3);
					Time arrival = rs12.getTime(4);
					int Diff = order.compareTo(arrival);
					if (Diff == 1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Early");
						PerfReport.add(perf);
					}
					if (Diff == 0) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Exactly");
						PerfReport.add(perf);
					}
					if (Diff == -1) {
						PerformenceReport perf = new PerformenceReport(rs12.getInt(1), rs12.getString(2),
								rs12.getTime(3), rs12.getTime(4), "Late");
						PerfReport.add(perf);
					}
				}
			}

		}
		System.out.println(PerfReport);
		if (PerfReport.size() == 0 && flag == true) {
			return "NotOpened";
		}
		if (flag) {
			return "Done";
		}
		return "NotOpened";
	}

	static void CreateInComeReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		incomearr = new ArrayList<InComeReport>();
		double income = 0;
		try {
			Statement stmt1 = conn.createStatement();
			Statement stmt2 = conn.createStatement();
			Statement stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				income = 0;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int ItemID = Integer.parseInt(rs2.getString(2));
					int sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						income += sold * rs3.getDouble(3);
					}
				}
				InComeReport ICR = new InComeReport(RestaurantName, income);
				incomearr.add(ICR);
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "InCome");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < incomearr.size(); i++) {
				String query1 = " insert into assignment3.incomereports (ID,RestaurantName,InCome)"
						+ " values (?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, incomearr.get(i).getRestaurantName());
				preparedStmt1.setDouble(3, incomearr.get(i).getIncome());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}

	static void CreateOrdersReport(String location, int month, int year) throws SQLException {
		boolean flag = false;
		boolean flag2 = false;
		Statement stmt1;
		Statement stmt2;
		Statement stmt3;
		ordersReport = new ArrayList<OrdersReport>();
		try {
			stmt1 = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			ResultSet rs1 = stmt1
					.executeQuery("SELECT * FROM assignment3.restaurant where location='" + location + "'");
			while (rs1.next() == true) {
				flag = true;
				int IDRestaurant = rs1.getInt(1);
				String RestaurantName = rs1.getString(2);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				while (rs2.next() == true) {
					int sold = rs2.getInt(3);
					int ItemID = Integer.parseInt(rs2.getString(2));
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					while (rs3.next() == true) {
						String Catalog = rs3.getString(4);
						OrdersReport Order = new OrdersReport(RestaurantName, Catalog, sold);
						for (int i = 0; i < ordersReport.size(); i++) {
							if (ordersReport.get(i).getRestaurantName().equals(Order.getRestaurantName())
									&& ordersReport.get(i).getCatalog().equals(Order.getCatalog())) {
								ordersReport.get(i).setSold(ordersReport.get(i).getSold() + Order.getSold());
								flag2 = true;
							}
						}
						if (!flag2)
							ordersReport.add(Order);
						flag2 = false;
					}
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		if (flag) {
			String query2 = " insert into assignment3.reports (Type,Location,Year,Month,ID)"
					+ " values (?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, "Order");
			preparedStmt2.setString(2, location);
			preparedStmt2.setInt(3, year);
			preparedStmt2.setInt(4, month);
			preparedStmt2.setInt(5, ReportIDCounter);
			preparedStmt2.execute();

			for (int i = 0; i < ordersReport.size(); i++) {
				String query1 = " insert into assignment3.ordersreport (ID,RestaurantName,Catalog,Sold)"
						+ " values (?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setInt(1, ReportIDCounter);
				preparedStmt1.setString(2, ordersReport.get(i).getRestaurantName());
				preparedStmt1.setString(3, ordersReport.get(i).getCatalog());
				preparedStmt1.setInt(4, ordersReport.get(i).getSold());
				preparedStmt1.execute();
			}
			ReportIDCounter++;
		}

	}
/////////////////////////////////////////////////////////////////

	public static void insidealldatafromBiteMeDB() throws SQLException {
		userfrombitemedata = new ArrayList<User>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From biteme_data.users");
		User user = null;
		while (RS.next()) {
			try {
				user = new User(RS.getString(1), RS.getString(4), RS.getString(5), RS.getString(8), RS.getString(2),
						RS.getString(6), RS.getString(7), RS.getString(3), RS.getString(14), RS.getString(13), 0,
						Integer.parseInt(RS.getString(11)), RS.getString(12), Integer.parseInt(RS.getString(10)),
						Integer.parseInt(RS.getString(15)));
				userfrombitemedata.add(user);
				String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
						+ " values (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt = conn.prepareStatement(query);
				preparedStmt.setString(1, user.getID());
				preparedStmt.setString(2, user.getUserName());
				preparedStmt.setString(3, user.getPassword());
				preparedStmt.setString(4, user.getUserType());
				preparedStmt.setInt(5, 0);
				preparedStmt.setInt(6, user.getConfirm());
				preparedStmt.setString(7, user.getStatus());
				preparedStmt.execute();
			} catch (Exception e) {
				System.out.println("importing data ...");
			}
			switch (user.getUserType()) {
			case "BranchManager":
				String query1 = " insert into assignment3.branchmanager (ID,FirstName,LastName,Email,PhoneNumber,location)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
				preparedStmt1.setString(1, user.getID());
				preparedStmt1.setString(2, user.getFirstname());
				preparedStmt1.setString(3, user.getLastname());
				preparedStmt1.setString(4, user.getEmail());
				preparedStmt1.setString(5, user.getPhonenumber());
				preparedStmt1.setString(6, user.getLocation());
				preparedStmt1.execute();
				break;
			case "Normal":
				String query2 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
				preparedStmt2.setString(1, user.getID());
				preparedStmt2.setString(2, user.getFirstname());
				preparedStmt2.setString(3, user.getLastname());
				preparedStmt2.setString(4, user.getEmail());
				preparedStmt2.setString(5, user.getPhonenumber());
				preparedStmt2.setInt(6, user.getVisaavailable());
				preparedStmt2.execute();
				break;
			case "Bussiness":
				String query3 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt3 = conn.prepareStatement(query3);
				preparedStmt3.setString(1, user.getID());
				preparedStmt3.setString(2, user.getFirstname());
				preparedStmt3.setString(3, user.getLastname());
				preparedStmt3.setString(4, user.getEmail());
				preparedStmt3.setString(5, user.getPhonenumber());
				preparedStmt3.setString(6, user.getCompany());
				preparedStmt3.execute();
				break;
			case "CEO":
				String query4 = " insert into assignment3.ceouser (ID,FirstName,LastName,Email,PhoneNumber)"
						+ " values (?, ?, ?, ?, ?)";
				PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
				preparedStmt4.setString(1, user.getID());
				preparedStmt4.setString(2, user.getFirstname());
				preparedStmt4.setString(3, user.getLastname());
				preparedStmt4.setString(4, user.getEmail());
				preparedStmt4.setString(5, user.getPhonenumber());
				preparedStmt4.execute();
				break;
			case "RestaurantManager":
				String query5 = " insert into assignment3.restaurantmanager (ID,FirstName,LastName,Email,PhoneNumber,IDRestaurant)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt5 = conn.prepareStatement(query5);
				preparedStmt5.setString(1, user.getID());
				preparedStmt5.setString(2, user.getFirstname());
				preparedStmt5.setString(3, user.getLastname());
				preparedStmt5.setString(4, user.getEmail());
				preparedStmt5.setString(5, user.getPhonenumber());
				preparedStmt5.setInt(6, user.getIdrestaurant());
				preparedStmt5.execute();
				break;
			case "HR":
				Statement stmt;
				String query6 = " insert into assignment3.hruser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
				preparedStmt6.setString(1, user.getID());
				preparedStmt6.setString(2, user.getFirstname());
				preparedStmt6.setString(3, user.getLastname());
				preparedStmt6.setString(4, user.getEmail());
				preparedStmt6.setString(5, user.getPhonenumber());
				preparedStmt6.setString(6, user.getCompany());
				preparedStmt6.execute();

				break;
			case "Worker":
				String query7 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
						+ " values (?, ?, ?, ?, ?,?)";
				PreparedStatement preparedStmt7 = conn.prepareStatement(query7);
				preparedStmt7.setString(1, user.getID());
				preparedStmt7.setString(2, user.getFirstname());
				preparedStmt7.setString(3, user.getLastname());
				preparedStmt7.setString(4, user.getEmail());
				preparedStmt7.setString(5, user.getPhonenumber());
				preparedStmt7.setInt(6, user.getIdrestaurant());
				preparedStmt7.execute();

				break;
			}
		}
	}

	public static void deletealldata() throws SQLException {
		Statement ps = conn.createStatement();

		PreparedStatement st, st1, st2 = null, st3 = null;

		ResultSet rs = ps.executeQuery("SELECT * FROM assignment3.users where confirm=0");
		while (rs.next() == true) {
			String ID = rs.getString(1);
			String type = rs.getString(4);

			if (type.equals("Normal")) {
				st = conn.prepareStatement("DELETE FROM assignment3.normaluser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("Bussiness")) {
				st = conn.prepareStatement("DELETE FROM assignment3.bussinessuser  where ID='" + ID + "'");
				st.executeUpdate();
			} else if (type.equals("BranchManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.branchmanager");
				st.executeUpdate();
			} else if (type.equals("CEO")) {
				st = conn.prepareStatement("DELETE FROM assignment3.ceouser");
				st.executeUpdate();
			} else if (type.equals("RestaurantManager")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantmanager");
				st.executeUpdate();
			} else if (type.equals("HR")) {
				st = conn.prepareStatement("DELETE FROM assignment3.hruser");
				st.executeUpdate();
			} else if (type.equals("Worker")) {
				st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker");
				st.executeUpdate();
			}
		}
		st = conn.prepareStatement("DELETE FROM assignment3.users WHERE confirm = ?");
		st.setInt(1, 0);
		st.executeUpdate();
	}

	// public WorkerUser(String userID, String firstName, String lastName, String
	// userName, String password, String email,
	// String phoneNumber, int iDRestaurant) {
	public static void LogOutAllAccounts() throws SQLException {
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? ");
		ps.setInt(1, 0);
		ps.executeUpdate();
	}

	public static String AddNewUser(User user, Object msgData1, String table) throws SQLException {
		PreparedStatement st;
		try {
			Statement stmt = conn.createStatement();

			ResultSet rs1 = stmt
					.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			ResultSet rs3 = stmt.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs3.next() == true) {
				return "IDAlreadyExists";
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		if (table.equals("normaluser")) {
			W4CNormal w4c = (W4CNormal) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, user.getID());
			preparedStmt1.setString(2, user.getFirstname());
			preparedStmt1.setString(3, user.getLastname());
			preparedStmt1.setString(4, user.getEmail());
			preparedStmt1.setString(5, user.getPhonenumber());
			preparedStmt1.setInt(6, user.getVisaavailable());
			preparedStmt1.execute();

			String query6 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt6 = conn.prepareStatement(query6);
			preparedStmt6.setString(1, code);
			preparedStmt6.setString(2, w4c.getUser().getID());
			preparedStmt6.execute();

		} else {
			W4CBussiness w4c = (W4CBussiness) msgData1;
			String code = String.valueOf(w4c.getCode());
			String query2 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,Email,PhoneNumber,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, user.getID());
			preparedStmt2.setString(2, user.getFirstname());
			preparedStmt2.setString(3, user.getLastname());
			preparedStmt2.setString(4, user.getEmail());
			preparedStmt2.setString(5, user.getPhonenumber());
			preparedStmt2.setString(6, user.getCompany());
			preparedStmt2.execute();

			String query4 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt4 = conn.prepareStatement(query4);
			preparedStmt4.setString(1, code);
			preparedStmt4.setDouble(2, w4c.getMoney());
			preparedStmt4.setString(3, w4c.getUser().getID());
			preparedStmt4.execute();

		}
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? , UserType=? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, user.getUserType());
		ps.setString(4, user.getID());
		ps.executeUpdate();

		return "updated";
	}

	public static String AddNewUserwithvisa(User user, Object msgData1, Visa visa, String table) throws SQLException {
		String str = AddNewUser(user, msgData1, table);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.normaluser SET VisaIsAvailable= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, user.getID());
		ps.executeUpdate();

		return str;
	}

	public static void confirmCompane(String cname) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where companyname='" + cname + "'");
		if (rs.next() != true) {
			String query1 = " insert into assignment3.company (companyname,confirm)" + " values (?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, cname);
			preparedStmt1.setInt(2, 0);
			preparedStmt1.execute();
		}
	}

	public static void companyConfirm(String cname) throws SQLException {
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.company SET confirm= ? WHERE companyname = ?");
		ps.setInt(1, 1);
		ps.setString(2, cname);
		ps.executeUpdate();
	}

	public static ArrayList<Company> getCompanyList() {
		Statement stmt;
		CompanyList = new ArrayList<Company>();
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.company where confirm='" + 0 + "'");
			while (rs.next() == true) {
				Company company = new Company(rs.getString(1), rs.getInt(2));
				CompanyList.add(company);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return CompanyList;
	}

	public static ArrayList<User> TakeAllUserThatNotConfiredyet() throws SQLException {
		TakeAllUserThatNotConfiredyet = new ArrayList<>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT * From assignment3.users where UserType= 'null'");
		User users;
		while (RS.next()) {
			String id = RS.getString(1);

			for (int i = 0; i < userfrombitemedata.size(); i++) {
				if (id.equals(userfrombitemedata.get(i).getID())) {
					TakeAllUserThatNotConfiredyet.add(userfrombitemedata.get(i));
				}
			}
		}
		return TakeAllUserThatNotConfiredyet;
	}

	public static ArrayList<Company> GetallAvailableCompany() throws SQLException {
		companys = new ArrayList<Company>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.company where confirm=1");
		Company company;
		while (RS.next()) {
			company = new Company(RS.getString(1), Integer.parseInt(RS.getString(2)));
			companys.add(company);
		}
		return companys;

	}

	///////////////
	public static ArrayList<Order> GetAllOrder(int id) throws NumberFormatException, SQLException {
		AllOrder = new ArrayList<Order>();
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("SELECT* From assignment3.order where RestaurantID='" + id + "'");
		Order order;
		while (RS.next()) {
			order = new Order(Integer.parseInt(RS.getString(1)), Double.parseDouble(RS.getString(5)), RS.getString(4),
					RS.getString(6), RS.getString(3));
			AllOrder.add(order);
		}
		return AllOrder;
	}

	/////////////////////
	public static void UpdateItem(Item item, String str) throws SQLException {
		PreparedStatement ps, ps1;
		ps1 = conn.prepareStatement("UPDATE assignment3.menu SET quantity= ? WHERE Item_ID = ?");
		ps1.setInt(1, item.getQuantity());
		ps1.setInt(2, item.getItem_ID());
		ps1.executeUpdate();
		ps = conn.prepareStatement("UPDATE assignment3.item SET Item_name= ?, Item_price=? WHERE Item_ID = ?");
		ps.setString(1, item.getItem_Name());
		ps.setDouble(2, item.getPrice());
		ps.setInt(3, item.getItem_ID());
		ps.executeUpdate();

	}

//////////////////
	public static void RemoveItem(Item item) throws SQLException {
		PreparedStatement st, st1;
		st1 = conn.prepareStatement("DELETE FROM assignment3.menu WHERE Item_ID = ?");
		st1.setInt(1, item.getItem_ID());
		st1.executeUpdate();
		st = conn.prepareStatement("DELETE FROM assignment3.item WHERE Item_ID = ?");
		st.setInt(1, item.getItem_ID());
		st.executeUpdate();

	}

	//////////////////
	public static void RemoveItemAddition(Item item, String addition) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.item_addition WHERE name=? and Item_ID = ?");
		st.setString(1, addition);
		st.setInt(2, item.getItem_ID());
		st.executeUpdate();

		st1 = conn.prepareStatement("DELETE FROM assignment3.addition WHERE name = ?");
		st1.setString(1, addition);
		st1.executeUpdate();

	}

	/////////////////
	public static void AddItems(Item item, Addition addition, int resid, String str) throws SQLException {
		if (addition == null) {
			String query = " insert into assignment3.item (item_ID,Item_name,Item_price,category)"
					+ " values (?, ?,?,?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setInt(1, item.getItem_ID());
			preparedStmt.setString(2, item.getItem_Name());
			preparedStmt.setDouble(3, item.getPrice());
			preparedStmt.setString(4, str);
			preparedStmt.execute();
			String query1 = " insert into assignment3.menu (IDRestaurant,item_ID,quantity)" + " values (?, ?,?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setInt(1, resid);
			preparedStmt1.setInt(2, item.getItem_ID());
			preparedStmt1.setInt(3, item.getQuantity());
			preparedStmt1.execute();
		} else {
			String query = " insert into assignment3.addition (name)" + " values (?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, addition.getName());
			preparedStmt.execute();
			String query2 = " insert into assignment3.item_addition (item_ID,name)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setInt(1, item.getItem_ID());
			preparedStmt2.setString(2, addition.getName());
			preparedStmt2.execute();

		}
	}

	public static ArrayList<WorkerUser> GetAllWorkers(int id) throws Exception// get all worker
	{
		ArrayList<WorkerUser> allworker = new ArrayList<WorkerUser>();
		Statement ps = conn.createStatement();
		Statement ps1 = conn.createStatement();
		WorkerUser WorkerUser;
		ResultSet RS = ps
				.executeQuery("SELECT * From assignment3.restaurantworker where restaurantWorker='" + id + "'");
		while (RS.next()) {
			String idres = RS.getString(1);
			ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.users where ID='" + idres + "'");
			if (RS1.next()) {
				WorkerUser = new WorkerUser(RS1.getString(1), RS.getString(2), RS.getString(3), RS1.getString(2),
						RS1.getString(3), RS.getString(4), RS.getString(5), id);
				WorkerUser.setRestaurantName(getrestaurantname(id).getResturaunt_Name());
				allworker.add(WorkerUser);

			}
		}
		return allworker;
	}

	public static void UpdateStatusOfUsers(User user1) throws SQLException {
		// System.out.println("user status updated ...." + user1.getUserName());
		PreparedStatement ps;

		ps = conn.prepareStatement("UPDATE assignment3.users SET status= ? WHERE ID = ?");
		ps.setString(1, user1.getStatus());
		ps.setString(2, user1.getID());
		ps.executeUpdate();

	}

	public static void BussinessAccountHasBeenAccepted(User user) throws SQLException {/// this method that accepted
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setString(1, "1");
		ps.setString(2, "Active");

		ps.setString(3, user.getID());
		ps.executeUpdate();
	}

	// add new business account
	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser, String str)
			throws SQLException {

		System.out.println("i am getting into login query");
		try {
			Statement stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}

			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cbussiness (code,money,IDuser)" + " values (?, ?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, str);
			preparedStmt2.setFloat(2, bussinessUser.getW4C());
			preparedStmt2.setString(3, bussinessUser.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	// add new bussiness account with visa
	static String InsertNewBussinessAccountWithVisa(Visa visa, User user, BussinessUser bussinessUser, String str)
			throws SQLException {
		String value = InsertNewBussinessAccount(user, bussinessUser, str);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();
		return value;

	}

	static int IDForW4C() {
		Random rand = new Random();
		Statement stmt, stmt1;
		try {
			while (true) {
				int W4C = rand.nextInt((999 - 100) + 1) + 100;
				stmt = conn.createStatement();
				stmt1 = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cnormal where code= '" + W4C + "'");
				if (!rs.next()) {
					ResultSet rs1 = stmt
							.executeQuery("SELECT * FROM assignment3.w4cbussiness where code= '" + W4C + "'");
					if (!rs1.next()) {
						System.out.println(W4C);
						return W4C;
					}
				}
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return 5;
	}

//////////////////////
	public static void RefundCustomer(int number) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		stmt1= conn.createStatement();

		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.order where orderNum='"+number+"'");
		if (rs.next() == true) {
			String userid=rs.getString(3);
			ResultSet rs1= stmt1.executeQuery("SELECT * FROM assignment3.users where ID='"+userid+"'");
			if (rs1.next() == true) {
				String type=rs1.getString(4);
				if(type.equals("Bussiness"))
				{
					Double price=rs.getDouble(5);
					price*0.5
				}
			}
		}
	}

	static String LogInChecker(User username) throws SQLException {
		Statement stmt, stmt1;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where UserName='" + username.getUserName()
				+ "' and Password='" + username.getPassword() + "'");
		if (rs.next() == true) {
			if (rs.getInt(5) == 1)
				return "LoggedIn";

			if (rs.getString(7).equals("Locked")) {
				return "Locked";
			}
			LoginUser = new User(rs.getString(1), username.getUserName(), rs.getString(3), rs.getString(4),
					Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
			return "Entered";
		}
		return "NotExist";
	}

	public static String InsertNewBussinessAccount(User user, BussinessUser bussinessUser) throws SQLException {
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, bussinessUser.getID());
			preparedStmt1.setString(2, bussinessUser.getFirstName());
			preparedStmt1.setString(3, bussinessUser.getLastName());
			preparedStmt1.setString(4, bussinessUser.getPhoneNumber());
			preparedStmt1.setString(5, bussinessUser.getEmail());
			preparedStmt1.setString(6, bussinessUser.getCompany());
			preparedStmt1.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	static User selectuserfromNormalUserTable(User username) {// check if the password and the user name is correct , if
		// yes then send the
// right message

		Statement stmt;
		int status;
		boolean valid = false;
		String usernameStatus;
		String Status;
		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + username.getID() + "'");
			if (rs.next() == true) {
				Status = rs.getString(10);
				user = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));

				usernameStatus = username.getUserName();
				status = rs.getInt("IsLoggedIn");
			}
			return user;

		} catch (SQLException e) {
			e.printStackTrace();
		}

		return null;

	}

	public static void AcceptNewNormalUser(User username) throws SQLException {
		System.out.println(username.getID());
		PreparedStatement ps;
		ps = conn.prepareStatement("UPDATE assignment3.users SET confirm= ? , status= ? WHERE ID = ?");
		ps.setInt(1, 1);
		ps.setString(2, "Active");
		ps.setString(3, username.getID());
		ps.executeUpdate();
	}

	public static void updateClientStatus(User user, int status) {
		System.out.println("user status updated ...." + user.getUserName());
		PreparedStatement ps, rs;
		try {
			ps = conn.prepareStatement("UPDATE assignment3.users SET IsLoggedIn= ? WHERE UserName = ?");
			ps.setInt(1, status);
			ps.setString(2, user.getUserName());

			if (ps.executeUpdate() != 0) {
				System.out.println("update " + user.getUserName() + " status to:" + status);

			} else {
				rs = conn.prepareStatement("UPDATE bitemeuser SET IsLoggedIn= ? WHERE UserName = ?");
				rs.setInt(1, status);
				rs.setString(2, user.getUserName());
				rs.executeUpdate();
			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static void deleteId(String id, String sqltable) throws SQLException {
		PreparedStatement st, st1, st2 = null, st3 = null;
		if (sqltable.equals("normaluser")) {
			st = conn.prepareStatement("DELETE FROM assignment3.normaluser WHERE ID = ?");
			st.setString(1, id);
			st.executeUpdate();
			st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
			st1.setString(1, id);
			st1.executeUpdate();
		}
		if (sqltable.equals("restaurant")) {
			st = conn.prepareStatement("DELETE FROM assignment3.restaurant WHERE IDRestaurant = ?");
			st.setInt(1, Integer.parseInt(id));
			st.executeUpdate();
		} else
			st3 = conn.prepareStatement("DELETE FROM assignment3.bussinessuser WHERE ID = ?");
		st3.setString(1, id);
		st3.executeUpdate();
		st2 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st2.setString(1, id);
		st2.executeUpdate();

	}

	static boolean getTheRequestList(String company) {
		requestsList = new ArrayList<BussinessUser>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps
					.executeQuery("SELECT * From assignment3.users where UserType='Bussiness' and status='Frozen'");
			BussinessUser request;
			while (RS.next()) {
				String id = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery(
						"SELECT * From assignment3.bussinessuser where ID='" + id + "'and Company='" + company + "'");
				if (RS1.next()) {
					request = new BussinessUser(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), 0, RS1.getString(6), 0);
					requestsList.add(request);

				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static boolean getAllUsers() {
		getlistofnormalaccount = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from assignment3.users where UserType= 'Normal' and confirm = 1");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				getlistofnormalaccount.add(request);
				System.out.print(getlistofnormalaccount);
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	static void putdatafrombitemeDB() {////////////////////////////////////////////////////////////////////////// WTF
		usersfromBiteMeDB = new ArrayList<User>();
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void isidedatafrombmtosassignment(ArrayList<User> user) {
		try {
			Statement ps = conn.createStatement();
			ResultSet rs = ps.executeQuery("SELECT * from biteme_data.bitemeuser");
			User request;
			while (rs.next()) {
				request = new User(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						Integer.parseInt(rs.getString(5)), Integer.parseInt(rs.getString(6)), rs.getString(7));
				usersfromBiteMeDB.add(request);
			}
			System.out.print(usersfromBiteMeDB);

		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	static void getAllResturaunt(String location) {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant where location='" + location + "'");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static void getAllResturaunt() {
		getAllresturaunt = new ArrayList<Resturaunt>();
		try {
			Statement ps = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * from assignment3.restaurant");

			Resturaunt request;
			while (RS.next()) {
				request = new Resturaunt(Integer.parseInt(RS.getString(1)), RS.getString(2), RS.getString(3));
				getAllresturaunt.add(request);

			}
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	public static ArrayList<RestaurantReport> GetReportForManager(int restaurantID, int month, int year)
			throws SQLException {
		ReportListForManager = new ArrayList<RestaurantReport>();
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;
		int month2 = month + 2;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();
			ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='" + restaurantID
					+ "' and Month>='" + month + "' and Month <='" + month2 + "' and Year='" + year + "'");
			System.out.println("dd");
			while (rs2.next() == true) {
				System.out.println("jj");
				ItemID = Integer.parseInt(rs2.getString(2));
				sold = Integer.parseInt(rs2.getString(3));
				ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
				System.out.println(ItemID);
				System.out.println(restaurantID);
				ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='" + restaurantID
						+ "' and Item_ID= '" + ItemID + "'");
				if (rs4.next() == true) {
					quantity1 = Integer.parseInt(rs4.getString(3));
					System.out.println(quantity1);
				}
				while (rs3.next() == true) {
					System.out.println("tat");
					System.out.println("Babi");
					rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1, Float.parseFloat(rs3.getString(3)),
							sold, sold * Float.parseFloat(rs3.getString(3)));
					System.out.println("add");
					ReportListForManager.add(rsp);
					System.out.println("ZZZZ");
				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println(ReportListForManager);

		return ReportListForManager;
	}

	public static W4CBussiness getW4CBussiness(User user) {
		W4CBussiness w4c = null;
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.w4cbussiness where IDuser=" + user.getID());
			if (rs.next()) {
				w4c = new W4CBussiness(rs.getInt(1), user, rs.getDouble(2));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return w4c;
	}

	static RestaurantManager GetRestaurantManager(User user) {
		Statement stmt, stmt1;
		int status;
		try {
			stmt1 = conn.createStatement();
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");

				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.restaurant where IDRestaurant='"
						+ Integer.parseInt(rs.getString(6)) + "'");
				if (rs1.next() == true) {
					restaurantManager = new RestaurantManager(rs.getString(1), rs.getString(2), rs.getString(3),
							rs.getString(4), rs.getString(5), Integer.parseInt(rs.getString(6)));
					System.out.println(restaurantManager);

					return restaurantManager;
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static void deleteOrder(int orderid) {
		Statement stmt;
		try {
			String SQL = "delete from assignment3.order where orderNum=?";
			PreparedStatement pstmt = null;

			// get a connection and then in your try catch for executing your delete...

			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_items where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
			SQL = "delete from assignment3.order_item_addition where orderNum=?";
			pstmt = conn.prepareStatement(SQL);
			pstmt.setInt(1, orderid);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public static boolean CheckDelivery(int orderid) {
		String sql = "select COUNT(*) from assignment3.delivery where orderNum=" + orderid;
		Statement st = null;
		try {
			st = conn.createStatement();
			ResultSet rs = st.executeQuery(sql);
			if (rs.next() == true) {
				String SQL = "delete from assignment3.delivery where orderNum=?";
				PreparedStatement pstmt = null;
				pstmt = conn.prepareStatement(SQL);
				pstmt.setInt(1, orderid);
				pstmt.executeUpdate();
				return true;
			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return false;
	}

	public static String GetDeliveryDate(int orderid) {
		Statement stmt;
		String date = "";
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("select * from assignment3.delivery where orderNum=" + orderid);
			date = rs.getString(6);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return date;
	}

	static WorkerUser GetRestaurantWorker(User user) {///////////////////////////////////////////
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.restaurantworker where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				System.out.println("I'm getting RestaurantManager from DB");
				WorkerUser = new WorkerUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return WorkerUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	private static String getitemname(int itemid) throws SQLException {
		Statement stmt, stmt1;
		stmt1 = conn.createStatement();
		String str = null;
		ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + itemid + "'");
		if (rs1.next() == true) {
			str = rs1.getString(2);

		}
		return str;
	}

/////////////////////////////////////
	public static ArrayList<ItemAddition> GetallOrederItems(int ordernum) throws SQLException {
		Statement stmt, stmt1;

		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ArrayList<ItemAddition> itemsandAddition1 = new ArrayList<>();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.order_item_addition where orderNum='" + ordernum + "'");
		while (rs.next()) {
			int itemid = rs.getInt(2);
			String str = rs.getString(3);
			ItemAddition a = (new ItemAddition(getitemname(itemid), str));
			itemsandAddition1.add(a);
		}
		System.out.print("****&****");
		System.out.print(itemsandAddition1);
		return itemsandAddition1;
	}

	public static String getuser(String id) throws SQLException {
		Statement stmt, stmt1;
		int status;
		String mail = null;
		stmt = conn.createStatement();
		stmt1 = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + id + "'");
		if (rs.next() == true) {
			String type = rs.getString(4);
			switch (type) {
			case "Normal":
				ResultSet rs1 = stmt1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + id + "'");
				if (rs1.next() == true) {
					mail = rs1.getString(4);
					return mail;
				}
				break;
			case "Bussiness":
				ResultSet rs2 = stmt1.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + id + "'");
				if (rs2.next() == true) {
					mail = rs2.getString(4);
					return mail;
				}
				break;

			}
		}
		return mail;
	}

	static BranchManager GetBranchManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.branchmanager where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				branchManager = new BranchManager(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6));
				return branchManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static CEOuser CeoUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.ceouser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				CEOuser1 = new CEOuser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5));
				return CEOuser1;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	static BussinessUser GetBissnessUser(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * FROM assignment3.bussinessuser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				W4CBussiness w4c = getW4CBussiness(user);
				BussinessUser = new BussinessUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), rs.getString(6), w4c);
				return BussinessUser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding BissessUser!!!");
		return null;
	}

	static Resturaunt getrestaurantname(int id) throws SQLException {
		Statement stmt;
		stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery("SELECT *  FROM assignment3.restaurant where IDRestaurant= " + id);
		if (rs.next() == true) {
			Resturaunt = new Resturaunt(Integer.parseInt(rs.getString(1)), rs.getString(2), rs.getString(3));
			return Resturaunt;
		}
		return null;

	}

	static HRUser GetHRManager(User user) {
		Statement stmt;
		int status;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.hruser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				HRManager = new HRUser(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(6));
				return HRManager;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;

	}

	public static Normal getNormalUser(User user) throws SQLException {
		Normal nuser = null;

		Statement st;
		ResultSet rs = null;
		try {
			st = conn.createStatement();
			rs = st.executeQuery("Select * from assignment3.normaluser where ID=" + user.getID());
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

		if (rs.next()) {
			try {
				nuser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4), rs.getString(5));
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return nuser;

	}

	public static Normal Getnormaluser(User user) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT * From assignment3.normaluser where ID='" + user.getID() + "'");
			if (rs.next() == true) {
				Normaluser = new Normal(rs.getString(1), rs.getString(2), rs.getString(3), rs.getString(4),
						rs.getString(5), Integer.parseInt(rs.getString(6)));
				return Normaluser;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("Error in finding !!!");
		return null;
	}

	public static ArrayList<RestaurantReport> GetReportForRestaurant(RestaurantManager restaurantManager, int month,
			int year) throws SQLException {
		ReportList = new ArrayList<RestaurantReport>();
		Statement stmt;
		Statement stmt2;
		Statement stmt3;
		Statement stmt4;

		int IDRestaurant;
		int ItemID;
		int sold;
		int quantity1 = 0;
		RestaurantReport rsp;
		System.out.println("Getting Report List from DB");
		try {
			stmt = conn.createStatement();
			stmt2 = conn.createStatement();
			stmt3 = conn.createStatement();
			stmt4 = conn.createStatement();

			System.out.println("aa");
			System.out.println(restaurantManager.getUserName());

			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.restaurantmanager where ID='" + restaurantManager.getUserID() + "'");
			System.out.println("bb");
			if (rs.next() == true) {
				System.out.println("cc");
				IDRestaurant = Integer.parseInt(rs.getString(6));
				System.out.println(IDRestaurant);
				ResultSet rs2 = stmt2.executeQuery("SELECT * FROM assignment3.solditem where IDRestaurant='"
						+ IDRestaurant + "' and Month='" + month + "' and Year='" + year + "'");
				System.out.println("dd");
				while (rs2.next() == true) {
					System.out.println("jj");
					ItemID = Integer.parseInt(rs2.getString(2));
					sold = Integer.parseInt(rs2.getString(3));
					ResultSet rs4 = stmt4.executeQuery("SELECT * FROM assignment3.menu where IDRestaurant='"
							+ IDRestaurant + "' and Item_ID= '" + ItemID + "'");
					if (rs4.next() == true) {
						quantity1 = Integer.parseInt(rs4.getString(3));
						System.out.println(quantity1);
					}
					ResultSet rs3 = stmt3.executeQuery("SELECT * FROM assignment3.item where Item_ID='" + ItemID + "'");
					System.out.println("mm");
					while (rs3.next() == true) {
						System.out.println("tat");
						rsp = new RestaurantReport(ItemID, rs3.getString(2), quantity1,
								Float.parseFloat(rs3.getString(3)), sold, sold * Float.parseFloat(rs3.getString(3)));
						System.out.println("add");
						ReportList.add(rsp);
						System.out.println("ZZZZ");
					}

				}

			}

		} catch (SQLException e) {
			e.printStackTrace();
		}
		System.out.println("z");
		return ReportList;
	}

	public static String AddNewWorker(WorkerUser WorkerUser) throws SQLException {
		Statement stmt;

		stmt = conn.createStatement();
		ResultSet rs = stmt
				.executeQuery("SELECT * FROM assignment3.users where UserName='" + WorkerUser.getUserName() + "'");
		if (rs.next() == true) {
			return "UserNameAlreadyExists";
		}
		ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + WorkerUser.getUserID() + "'");
		if (rs1.next() == true) {
			return "IDAlreadyExists";
		}
		String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
				+ " values (?, ?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt = conn.prepareStatement(query);
		preparedStmt.setString(1, WorkerUser.getUserID());
		preparedStmt.setString(2, WorkerUser.getUserName());
		preparedStmt.setString(3, WorkerUser.getPassword());
		preparedStmt.setString(4, "Worker");
		preparedStmt.setInt(5, 0);
		preparedStmt.setInt(6, 1);
		preparedStmt.setString(7, "Active");
		preparedStmt.execute();

		String query1 = " insert into assignment3.restaurantworker (ID,FirstName,LastName,Email,PhoneNumber,restaurantWorker)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, WorkerUser.getUserID());
		preparedStmt1.setString(2, WorkerUser.getFirstName());
		preparedStmt1.setString(3, WorkerUser.getLastName());
		preparedStmt1.setString(4, WorkerUser.getEmail());
		preparedStmt1.setString(5, WorkerUser.getPhoneNumber());
		preparedStmt1.setInt(6, WorkerUser.getIDRestaurant());
		preparedStmt1.execute();
		return "Updated";

	}

	public static void RemoveWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement st, st1;
		st = conn.prepareStatement("DELETE FROM assignment3.restaurantworker  WHERE ID = ?");
		st.setString(1, WorkerUser.getUserID());
		st.executeUpdate();
		st1 = conn.prepareStatement("DELETE FROM assignment3.users WHERE ID = ?");
		st1.setString(1, WorkerUser.getUserID());
		st1.executeUpdate();
	}

	public static void EditWorker(WorkerUser WorkerUser) throws SQLException {
		PreparedStatement ps, rs;

		ps = conn.prepareStatement(
				"UPDATE assignment3.restaurantworker SET FirstName= ?,LastName=?,Email=?,PhoneNumber=?  WHERE ID = ?");
		ps.setString(1, WorkerUser.getFirstName());
		ps.setString(2, WorkerUser.getLastName());
		ps.setString(3, WorkerUser.getEmail());
		ps.setString(4, WorkerUser.getPhoneNumber());
		ps.setString(5, WorkerUser.getUserID());
		ps.executeUpdate();
		rs = conn.prepareStatement("UPDATE assignment3.users SET UserName= ?,Password=? WHERE ID = ?");
		rs.setString(1, WorkerUser.getUserName());
		rs.setString(2, WorkerUser.getPassword());
		rs.setString(3, WorkerUser.getUserID());
		rs.executeUpdate();

	}

	public static String Create_acceptRestaurant(Resturaunt res) throws SQLException {
		PreparedStatement ps;
		try {
			String query1 = " insert into assignment3.restaurant (IDRestaurant,RestaurantName,location)"
					+ " values (?, ?, ?)";
			ps = conn.prepareStatement(query1);
			ps.setInt(1, res.getResturauntID());
			ps.setString(2, res.getResturaunt_Name());
			ps.setString(3, res.getLocation());
			ps.execute();
		} catch (Exception e) {
			return "This Id is Existes";
		}

		return "updated";

	}

	static boolean GetTheRequestNormalAccount() {
		NormalUsersNotAccepted = new ArrayList<Normal>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("SELECT * FROM assignment3.users where confirm= 0 ");
			Normal request;
			while (RS.next()) {
				String ID = RS.getString(1);
				ResultSet RS1 = ps1.executeQuery("SELECT * FROM assignment3.normaluser where ID='" + ID + "'");
				while (RS1.next()) {
					request = new Normal(RS1.getString(1), RS1.getString(2), RS1.getString(3), RS1.getString(4),
							RS1.getString(5), Integer.parseInt(RS1.getString(6)), Float.parseFloat(RS1.getString(7)));
					NormalUsersNotAccepted.add(request);
				}
			}
			return true;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return false;
	}

	public static void InsertNewNormalAccountWithVisa(Visa visa, User user, Normal NorUser) throws SQLException {
		InsertNewNormalAccountWithOutVisa(user, NorUser);
		String query1 = " insert into assignment3.visa (userID,Number,CVV,Year,CardHolderName,Month)"
				+ " values (?, ?, ?, ?, ?, ?)";
		PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
		preparedStmt1.setString(1, visa.getUserID());
		preparedStmt1.setString(2, visa.getNumber());
		preparedStmt1.setInt(3, visa.getCVV());
		preparedStmt1.setInt(4, visa.getYear());
		preparedStmt1.setString(5, visa.getCardHolderName());
		preparedStmt1.setInt(6, visa.getMonth());
		preparedStmt1.execute();

	}

	public static String InsertNewNormalAccountWithOutVisa(User user, Normal NorUser) throws SQLException {
		Statement stmt;

		System.out.println("i am getting into login query");
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt
					.executeQuery("SELECT * FROM assignment3.users where UserName='" + user.getUserName() + "'");
			if (rs.next() == true) {
				return "UserNameAlreadyExists";
			}
			ResultSet rs1 = stmt.executeQuery("SELECT * FROM assignment3.users where ID='" + user.getID() + "'");
			if (rs1.next() == true) {
				return "IDAlreadyExists";
			}
			String query = " insert into assignment3.users (ID,UserName,Password,UserType,IsLoggedIn,confirm,status)"
					+ " values (?, ?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getUserName());
			preparedStmt.setString(3, user.getPassword());
			preparedStmt.setString(4, user.getUserType());
			preparedStmt.setInt(5, user.getIsLoggedIn());
			preparedStmt.setInt(6, user.getConfirm());
			preparedStmt.setString(7, user.getStatus());
			preparedStmt.execute();

			String query1 = " insert into assignment3.normaluser (ID,FirstName,LastName,Email,Phone,VisaIsAvailable)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt1 = conn.prepareStatement(query1);
			preparedStmt1.setString(1, NorUser.getID());
			preparedStmt1.setString(2, NorUser.getFirstName());
			preparedStmt1.setString(3, NorUser.getLastName());
			preparedStmt1.setString(4, NorUser.getEmail());
			preparedStmt1.setString(5, NorUser.getPhoneNumber());
			preparedStmt1.setInt(6, NorUser.getVisaIsAvailable());
			preparedStmt1.execute();

			String query2 = " insert into assignment3.w4cnormal (code,IDuser)" + " values (?, ?)";
			PreparedStatement preparedStmt2 = conn.prepareStatement(query2);
			preparedStmt2.setString(1, String.valueOf(NorUser.getW4C()));
			preparedStmt2.setString(2, user.getID());
			preparedStmt2.execute();

		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	public static boolean updatePassword(User user) {
		System.out.println("user password updated ...." + user.getUserName());
		PreparedStatement ps;
		try {

			ps = conn.prepareStatement("UPDATE assignment3.users SET Password= ? WHERE ID = ?");
			ps.setString(1, user.getPassword());
			ps.setString(2, user.getID());

			if (ps.executeUpdate() == 0) {
				System.out.println("Table Update Error!");
				return false;
			} else {
				System.out.println("update user with ID:" + user.getID() + " password to " + user.getPassword());
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return true;
	}

	public static String InsertNewBussinessAccount(BussinessUser user) throws SQLException {
		Statement stmt;
		System.out.println("i am getting into login query");
		try {
			String query = " insert into assignment3.bussinessuser (ID,FirstName,LastName,PhoneNumber,Email,Company)"
					+ " values (?, ?, ?, ?, ?, ?)";
			PreparedStatement preparedStmt = conn.prepareStatement(query);
			preparedStmt.setString(1, user.getID());
			preparedStmt.setString(2, user.getFirstName());
			preparedStmt.setString(3, user.getLastName());
			preparedStmt.setString(4, user.getPhoneNumber());
			preparedStmt.setString(5, user.getEmail());
			preparedStmt.setString(6, user.getCompany());
			preparedStmt.execute();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return "Updated";
	}

	private static ArrayList<Addition> getAdditions(int itemId) {
		String sql = "select * from assignment3.item_addition where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		ArrayList<Addition> list = new ArrayList<Addition>();
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				Addition tmp = new Addition(rs.getString("name"));
				list.add(tmp);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return list;
	}

	// get item for specific menu
	private static Item getItems(int itemId) {
		String sql = "select * from assignment3.item where Item_ID=" + itemId;
		Statement st;
		ResultSet rs = null;
		Item item = null;
		ArrayList<Addition> list;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				String cat = rs.getString("category");
				Category c = Category.valueOf(cat.toString());
				list = getAdditions(itemId);
				item = new Item(itemId, rs.getString("Item_name"), rs.getDouble("Item_price"), c, list);
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return item;
	}

	// get menu for each restaurant, calls getItems function to get items for menu
	private static Menu getMenu(int ResId) {
		Menu m = null;
		Item item = null;
		Statement st = null;
		HashMap<Item, Integer> items2 = new HashMap<>();
		// ArrayList<Item> items = new ArrayList<>();
		ResultSet rs = null;
		String sql = "select * from assignment3.menu where IDRestaurant=" + ResId;
		try {
			st = conn.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				int itemId = rs.getInt("Item_ID");
				item = getItems(itemId);
				items2.put(item, rs.getInt("quantity"));
				// items.add(item);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		m = new Menu(items2);
		return m;
	}

	// return all restaurants from data base to display to the client
	public static ArrayList<Resturaunt> getAllResturaunts() {
		ArrayList<Resturaunt> resList = new ArrayList<>();
		ResultSet rs = null;
		PreparedStatement ps = null;
		String sql = "select * from assignment3.restaurant";
		try {
			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			while (rs.next()) {
				int ResId = rs.getInt("IDRestaurant");
				Menu m = getMenu(ResId);
				Resturaunt r = new Resturaunt(ResId, rs.getString("RestaurantName"), m);
				resList.add(r);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return resList;
	}

	public static String companyChecker(String cname11) {
		Statement stmt;
		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(
					"SELECT * FROM assignment3.company where confirm='" + 1 + "' and companyname='" + cname11 + "'");
			if (rs.next() == true) {
				return "companyExist";
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static W4CNormal getW4C(User user) {
		Statement stmt;
		W4CNormal w4c = null;
		String sql = null;
		if (user.getUserType().equals("Normal"))
			sql = "select * from assignment3.w4cnormal where IDuser=" + user.getID();
		else if (user.getUserType().equals("Bussiness"))
			sql = "select * from assignment3.w4cbussiness where IDuser=" + user.getID();

		try {
			stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			while (rs.next()) {
				if (user.getUserType().equals("Normal")) {
					w4c = new W4CNormal(rs.getInt(1), user);
					user.setW4c(w4c);
					System.out.println(user.getW4c().getCode());
				} else if (user.getUserType().equals("Bussiness")) {
					w4c = new W4CBussiness(rs.getInt(1), user, rs.getInt(2));
					user.setW4c(w4c);
				}
			}
		} catch (SQLException e) {

			e.printStackTrace();
		}
		return w4c;
	}

	public static ArrayList<Item> getallmaindish(int id, String type) throws SQLException {
		Item Items = null;
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Itemss = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					String cat = RS1.getString("category");
					Category c = Category.valueOf(cat.toString());
					addition = GetAllAddition(itemid);
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							(ArrayList<Addition>) addition, Integer.parseInt(RS.getString(3)), c);
					Items.setCate(cat);
					Itemss.add(Items);

				}
			}
			return Itemss;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static ArrayList<Addition> GetAllAddition(int itemid) throws SQLException {
		ArrayList<Addition> addition = new ArrayList<Addition>();
		Addition add;
		Statement ps = conn.createStatement();
		ResultSet RS = ps.executeQuery("select * from assignment3.item_addition where Item_ID='" + itemid + "'");
		while (RS.next()) {
			add = new Addition(RS.getString(2));
			addition.add(add);
			System.out.println(add + "im here");
		}
		return addition;
	}

	public static ArrayList<Item> getallitems(int id) throws SQLException {
		Item Items = null;

		AllItems = new ArrayList<Item>();
		try {
			Statement ps = conn.createStatement();
			Statement ps1 = conn.createStatement();
			ResultSet RS = ps.executeQuery("select * from assignment3.menu where IDRestaurant='" + id + "'");
			while (RS.next()) {
				int itemid = RS.getInt(2);
				ResultSet RS1 = ps1.executeQuery("SELECT * From assignment3.item where Item_ID='" + itemid + "'");
				if (RS1.next()) {
					Items = new Item(itemid, RS1.getString(2), Double.parseDouble(RS1.getString(3)),
							Integer.parseInt(RS.getString(3)));
					System.out.print(Items);
					AllItems.add(Items);

				}
			}
			return AllItems;
		} catch (SQLException e) {
// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	public static void generate_qr(String image_name, String qrCodeData) {
		try {
			System.out.println(image_name + " " + qrCodeData);
			String filePath = "D:\\" + image_name + ".png";
			String charset = "UTF-8"; // or "ISO-8859-1"
			Map<EncodeHintType, ErrorCorrectionLevel> hintMap = new HashMap<EncodeHintType, ErrorCorrectionLevel>();
			hintMap.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);
			BitMatrix matrix = new MultiFormatWriter().encode(new String(qrCodeData.getBytes(charset), charset),
					BarcodeFormat.QR_CODE, 200, 200, hintMap);
			MatrixToImageWriter.writeToFile(matrix, filePath.substring(filePath.lastIndexOf('.') + 1),
					new File(filePath));
			System.out.println("QR Code image created successfully!");
		} catch (Exception e) {
			System.err.println(e);
		}
	}

	@Override
	public void initialize(URL location, ResourceBundle resources) {
		// TODO Auto-generated method stub

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-28 16:25:12.723
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-28 16:25:12.723
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:449)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-28 19:00:57.109
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.core.jobs 4 2 2021-12-28 21:04:37.769
!MESSAGE An internal error occurred during: "Requesting Java AST from selection".
!STACK 0
java.lang.ArrayIndexOutOfBoundsException: Index 25 out of bounds for length 14
	at org.eclipse.jdt.internal.compiler.util.HashtableOfPackage.get(HashtableOfPackage.java:70)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getPackage0(LookupEnvironment.java:1620)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTopLevelPackage(LookupEnvironment.java:1656)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:542)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:619)
	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.getImport(CompilationUnitScope.java:701)
	at org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveName(DefaultBindingResolver.java:1381)
	at org.eclipse.jdt.core.dom.Name.resolveBinding(Name.java:88)
	at org.eclipse.jdt.internal.core.manipulation.search.OccurrencesFinder.visit(OccurrencesFinder.java:181)
	at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:198)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.QualifiedName.accept0(QualifiedName.java:163)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
	at org.eclipse.jdt.core.dom.ImportDeclaration.accept0(ImportDeclaration.java:206)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3042)
	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:257)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
	at org.eclipse.jdt.internal.core.manipulation.search.OccurrencesFinder.performSearch(OccurrencesFinder.java:104)
	at org.eclipse.jdt.internal.core.manipulation.search.OccurrencesFinder.getOccurrences(OccurrencesFinder.java:110)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.updateOccurrenceAnnotations(JavaEditor.java:3326)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.lambda$4(JavaEditor.java:3349)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:176)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:152)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.jobs 4 2 2021-12-28 21:05:22.839
!MESSAGE An internal error occurred during: "Requesting Java AST from selection".
!STACK 0
java.lang.ArrayIndexOutOfBoundsException
!SESSION 2021-12-28 21:38:16.477 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-28 21:38:18.187
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.484
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-28 21:38:22.485
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-28 21:38:23.549
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-28 21:38:23.550
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@628b1538,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36995784,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-28 21:38:28.508
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-28 21:49:39.471
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-28 21:52:13.999
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-28 21:52:14.967
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)
!SESSION 2021-12-29 00:18:48.318 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-29 00:18:50.030
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 00:18:52.919
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-29 00:18:53.993
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-29 00:18:53.993
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58dd1d0c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@740530b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-29 00:18:58.468
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-29 11:43:54.589 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-29 11:43:57.900
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 11:44:06.738
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-29 11:44:07.930
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-29 11:44:07.930
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7d453075,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16df0ebd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-29 11:44:13.228
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 12:38:17.040
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 12:52:54.598
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 12:56:35.040
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 12:59:58.939
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:12:17.662
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:13:27.446
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:16:22.298
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:21:39.724
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:22:01.478
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:27:24.431
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:27:37.658
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-29 13:33:46.650
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)
!SESSION 2021-12-29 17:32:26.189 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-29 17:32:38.817
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.118
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-29 17:32:45.119
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-29 17:32:46.206
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-29 17:32:46.206
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4c897417,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5a8d03ce,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-29 17:32:50.873
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-12-30 16:41:48.140 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-30 16:42:01.342
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.core.resources 2 10035 2021-12-30 16:42:03.479
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-30 16:42:04.088
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-30 16:42:05.250
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-30 16:42:05.250
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5ce7ab6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@28f7cca4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-30 16:42:10.075
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.wst.xml.ui 4 4 2021-12-30 20:50:15.169
!MESSAGE Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.core.IType.getSuperclassName()" because "t" is null
	at org.eclipse.fx.ide.model.internal.FXEventHandlerProperty.isEventHandler(FXEventHandlerProperty.java:38)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.getProperty(PropertiesUtil.java:144)
	at org.eclipse.fx.ide.model.internal.utils.PropertiesUtil.resolveProperties(PropertiesUtil.java:100)
	at org.eclipse.fx.ide.model.internal.FXClass.getLocalProperties(FXClass.java:143)
	at org.eclipse.fx.ide.model.internal.FXClass.getAllProperties(FXClass.java:135)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.checkControllerAttributes(FXMLValidator.java:156)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:123)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validateV1File(FXMLValidator.java:388)
	at org.eclipse.fx.ide.fxml.editors.FXMLValidator.validate(FXMLValidator.java:333)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.validate(ReconcileStepForValidator.java:252)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ReconcileStepForValidator.reconcileModel(ReconcileStepForValidator.java:210)
	at org.eclipse.jface.text.reconciler.AbstractReconcileStep.reconcile(AbstractReconcileStep.java:92)
	at org.eclipse.wst.sse.ui.internal.reconcile.validator.ValidatorStrategy.reconcile(ValidatorStrategy.java:270)
	at org.eclipse.wst.sse.ui.internal.reconcile.DocumentRegionProcessor.process(DocumentRegionProcessor.java:323)
	at org.eclipse.wst.sse.ui.internal.reconcile.StructuredRegionProcessor.process(StructuredRegionProcessor.java:260)
	at org.eclipse.wst.sse.ui.internal.reconcile.DirtyRegionProcessor$BackgroundThread.run(DirtyRegionProcessor.java:694)
!SESSION 2021-12-31 14:23:42.978 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-31 14:24:05.336
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 14:24:22.870
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-31 14:24:25.485
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-31 14:24:25.485
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7d6ccad7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4d9ad37e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-31 14:24:31.826
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:28:42.015
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:28:42.015
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:28:42.015
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:28:42.015
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:28:42.015
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:28:42.015
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:28:42.015
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:28:44.060
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:28:44.061
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:28:44.061
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:28:44.061
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:28:44.061
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:28:44.061
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:28:44.061
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SESSION 2021-12-31 16:41:42.618 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-31 16:41:51.286
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-31 16:43:04.761
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.761
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.761
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.761
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.761
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.761
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:43:04.762
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-31 16:43:05.881
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-31 16:43:05.881
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1d3bf0af,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4af0ae2c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-31 16:43:10.755
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:51:08.638
!MESSAGE JavaBuilder handling CoreException while building: Assignment3_Client
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/OCSF)[368]: java.lang.Exception: Resource '/OCSF' does not exist.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:330)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:204)
	at org.eclipse.core.internal.resources.Project.checkAccessible(Project.java:145)
	at org.eclipse.core.internal.resources.Project.getDescription(Project.java:391)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.hasJavaBuilder(JavaBuilder.java:599)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.isWorthBuilding(JavaBuilder.java:746)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:183)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2021-12-31 16:51:08.639
!MESSAGE Resource '/OCSF' does not exist.
!STACK 0
java.lang.Exception: Resource '/OCSF' does not exist.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:330)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:204)
	at org.eclipse.core.internal.resources.Project.checkAccessible(Project.java:145)
	at org.eclipse.core.internal.resources.Project.getDescription(Project.java:391)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.hasJavaBuilder(JavaBuilder.java:599)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.isWorthBuilding(JavaBuilder.java:746)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:183)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:56:20.685
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:56:20.685
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:56:20.685
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:56:20.685
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:20.685
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:20.685
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.resources.Workspace.buildInternal(Workspace.java:515)
	at org.eclipse.core.internal.resources.Workspace.build(Workspace.java:405)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:354)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:20.685
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:56:21.666
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:56:21.666
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:56:21.666
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:56:21.666
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:21.666
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:21.666
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:21.666
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:56:30.779
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:56:30.780
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:56:30.780
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:56:30.780
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:30.780
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:30.780
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:30.780
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:56:31.731
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:56:31.731
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:56:31.731
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:56:31.731
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:31.731
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:31.731
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:56:31.731
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SESSION 2021-12-31 16:56:36.885 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product -data file:/C:/Users/asem/eclipse-workspace/ -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2021-12-31 16:56:38.681
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.458
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2021-12-31 16:56:39.459
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'

!ENTRY org.eclipse.jface 2 0 2021-12-31 16:56:40.751
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-31 16:56:40.751
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55b7f9f1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@273e622f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-12-31 16:56:44.535
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\asem'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:59:36.204
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:59:36.206
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:59:36.206
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:59:36.206
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:59:36.206
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:59:36.206
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.clean(JavaBuilder.java:319)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:834)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:278)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:467)
	at org.eclipse.core.internal.resources.Project$1.run(Project.java:565)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:603)
	at org.eclipse.core.internal.resources.Project.build(Project.java:116)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog.doClean(CleanDialog.java:359)
	at org.eclipse.ui.internal.ide.dialogs.CleanDialog$1.runInWorkspace(CleanDialog.java:158)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:59:36.207
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.

!ENTRY org.eclipse.jdt.core 4 4 2021-12-31 16:59:38.182
!MESSAGE Error occurred while deleting: /Assignment3_Client/bin/icons
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:770)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete '/Assignment3_Client/bin/icons'.
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 1 org.eclipse.core.resources 4 273 2021-12-31 16:59:38.182
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 2 org.eclipse.core.resources 4 273 2021-12-31 16:59:38.182
!MESSAGE Could not delete '/Assignment3_Client/bin/icons'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Problems encountered while deleting resources.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:367)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Problems encountered while deleting files.
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SUBENTRY 3 org.eclipse.core.resources 4 273 2021-12-31 16:59:38.183
!MESSAGE Problems encountered while deleting resources.
!SUBENTRY 4 org.eclipse.core.filesystem 4 273 2021-12-31 16:59:38.183
!MESSAGE Problems encountered while deleting files.
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:59:38.183
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png.
!STACK 0
java.nio.file.FileSystemException: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons\BITEME.png: The process cannot access the file because it is being used by another process
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)
	at java.base/sun.nio.fs.AbstractFileSystemProvider.deleteIfExists(AbstractFileSystemProvider.java:110)
	at java.base/java.nio.file.Files.deleteIfExists(Files.java:1191)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:223)
	at org.eclipse.core.internal.filesystem.local.LocalFile.internalDelete(LocalFile.java:251)
	at org.eclipse.core.internal.filesystem.local.LocalFile.delete(LocalFile.java:140)
	at org.eclipse.core.internal.localstore.DeleteVisitor.delete(DeleteVisitor.java:66)
	at org.eclipse.core.internal.localstore.DeleteVisitor.visit(DeleteVisitor.java:154)
	at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:119)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.delete(FileSystemResourceManager.java:364)
	at org.eclipse.core.internal.resources.ResourceTree.internalDeleteFolder(ResourceTree.java:361)
	at org.eclipse.core.internal.resources.ResourceTree.standardDeleteFolder(ResourceTree.java:813)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1783)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:757)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.cleanOutputFolders(BatchImageBuilder.java:140)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:65)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:275)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:187)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:832)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:220)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:263)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:316)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:319)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:371)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:392)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:154)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 5 org.eclipse.core.filesystem 4 273 2021-12-31 16:59:38.183
!MESSAGE Could not delete: C:\Users\asem\eclipse-workspace\Assignment3_Client\bin\icons.
!SESSION 2022-01-01 20:03:38.525 -----------------------------------------------
eclipse.buildId=4.17.0.I20200902-1800
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.oomph.p2.core 2 0 2022-01-01 20:03:58.302
!MESSAGE Failed to register the thread safe credentials providers: 'java.util.Map org.eclipse.core.internal.runtime.AdapterManager.getFactories()'

!ENTRY org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.enclosing'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.next'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.previous'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.select.last'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.source.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.384
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.add.import'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.organize.imports'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.refactor.quickMenu'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.rename.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.move.element'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.modify.method.parameters'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.inline'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.method'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.extract.local.variable'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.edit.text.java.open.hierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.TypeHierarchy'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.PackageExplorer'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.SourceView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
!SUBENTRY 1 org.eclipse.ui 2 0 2022-01-01 20:04:01.385
!MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.wst.jsdt.ui', id='org.eclipse.wst.jsdt.ui.JavadocView'
